[{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Pv3Rs authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic workflow","title":"Demonstrate Pv3Rs usage","text":"first look synthetic example three episodes (episode names optional) three markers (marker names obligatory) whose alleles known frequencies. plot data using plot_data().  Different colours plotted data (left) represent different alleles. legend (right) shows alleles per marker one column per marker. order markers legend plotted data (see horizontal axis, left). allele frequencies specified, heights differently coloured areas legend proportional allele frequencies, s.t. rare alleles relatively small legend areas (e.g., T m2 rare). Aside Given maximum number alleles observed per-episode, parsimonious explanation 3, 2, 1 distinct parasite genotypes three episodes respectively (genotype defined realisation haploid parasite genome representing group clonal parasites). synthetic example, markers quart-allelic brevity; imposes rather low upper bound MOI estimates based maximum per-marker allele counts. reality, diverse markers recommended recurrent state inference. better MOI estimates available based diverse markers, data diverse markers added data input y compute_posterior(). better MOI estimates based heteroallelic marker counts across many markers available, used recurrent state inference specifying MOI argument function compute_posterior(). performing genetic recurrent state inference, bulk computational time lies computing log-likelihoods graphs relationships genotypes. call compute_posterior() specify prior, uniform prior across three recurrence states per recurrence assumed default. Marginal posterior probabilities (probabilities recrudescence C, relapse L, reinfection recurrence) stored post$marg. Marginal posterior probabilities can plotted simplex using function plot_simplex().  point yellow region likely recrudescence posterior probability greater 0.5 (falls bright yellow region); point red region likely reinfection posterior probability greater 0.5 (falls bright red region). Joint posterior probabilities (probabilities chronological sequences recrudescence C, relapse L, reinfection ) stored post$joint. , find likely sequence recurrence states r names(.max(post$joint)) posterior probability r post$joint[.max(post$joint)]","code":"y <- list(\"Enrollment\" = list(m1 = c('C','G','T'),                                m2 = c('A','C'),                               m3 = c('C','G','T')),           \"Recurrence 1\" = list(m1 = c('C','T'),                                  m2 = c('A'),                                  m3 = c('A','C')),           \"Recurrence 2\" = list(m1 = c('T'),                                  m2 = c('A'),                                  m3 = c('A')))  fs <- list(m1 = c(A = 0.27, C = 0.35, G = 0.18, T = 0.20),            m2 = c(A = 0.78, C = 0.14, G = 0.07, T = 0.01),            m3 = c(A = 0.21, C = 0.45, G = 0.26, T = 0.08)) plot_data(ys = list(\"Participant data\" = y), fs = fs) post <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrent states #> =============================================================================| post$marg #>                     C         L          I #> Recurrence 1 0.000000 0.3294555 0.67054446 #> Recurrence 2 0.670205 0.2388744 0.09092065 # Plot simplex par(mar = rep(0.1,4)) plot_simplex(v_labels = c(C = \"Recrudescence\",                            L = \"Relapse\",                            I = \"Reinfection\")[colnames(post$marg)])  # Project marginal posterior probabilties onto 2D coordinates xy <- apply(post$marg, 1, project2D)  xy_prior <- project2D(rep(1/3,3))   # Plot projection on the simplex points(x = xy[\"x\",], y = xy[\"y\",], pch = 20)  text(x = xy[\"x\",], y = xy[\"y\",], pos = 3, labels = gsub(\"_\", \" \", rownames(post$marg)))  # Add default prior per recurrence points(x = xy_prior[\"x\"], y = xy_prior[\"y\"], pch = 20) text(x = xy_prior[\"x\"], y = xy_prior[\"y\"], pos = 3, labels = \"Prior probability\") post$joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.21338194 0.45682305 0.00000000 0.08501504 0.15385932 0.00000000  #>         LI         II  #> 0.03105856 0.05986209"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"exploration-of-relationship-graphs-and-their-log-likelihoods","dir":"Articles","previous_headings":"","what":"Exploration of relationship graphs and their log likelihoods","title":"Demonstrate Pv3Rs usage","text":"want explore relationship graphs log likelihoods need set return.RG return.logp TRUE computing posterior; FALSE default (see ). compute posterior, summations per-marker allelic assignments equivalent within-episode genotype permutations redundant. , default, compute_posterior() sum , conserving memory compute time; see enumerate_alleles(). exploitation permutation symmetry requires scheme choose single representative among permutations otherwise equivalent. user-specified MOIs greater based per-marker allele counts, compute_posterior() sums permutations scheme complicated. Likewise, compute meaningful graph likelihood values (.e., values dependent aforementioned representative-choosing scheme), permutations summed return.logp = TRUE. recover posterior log-likelihood relationship graph also returned output. plot relationship graph(s) largest likelihood.  N.B. two symmetric graphs maximum likelihood: isomorphic within-episode genotype permutations. user note , current example, relationship graph(s) largest likelihood (e.g., ) might equivalence class data probable relationship graphs class summed (e.g., ). user also note , maximum-likelihood graph(s) might incompatible maximum-posterior state sequence (albeit true current example: graphs compatible IC) graphs maximum-likelihood equivalence class might incompatible maximum-posterior state sequence (true current example, given class largest likelihood contains graphs sibling edges incompatible IC).","code":"post <- compute_posterior(y, fs, return.RG = TRUE, return.logp = TRUE) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrent states #> =============================================================================| post$joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.21338194 0.45682305 0.00000000 0.08501504 0.15385932 0.00000000  #>         LI         II  #> 0.03105856 0.05986209 # Extract all log likelihoods lliks <- sapply(post$RGs, function(RG) RG$logp)  # Extract the relationship graphs (RGs) with the largest log likelihood RGs <- post$RGs[which(abs(lliks - max(lliks)) < .Machine$double.eps^0.5)]  # Generate genotype names  gs <- paste0(\"g\", 1:6)   # Generate episode indices for genotypes ts_per_gs <- rep(1:length(y), determine_MOIs(y))   # The sequences of states compatible with RGs seqs_comp <- sapply(RGs, compatible_rstrs, gs_per_ts = split(gs, ts_per_gs))  # Plot RG par(mar = rep(0.1,4), mfrow = c(1,2)) for(i in 1:length(RGs)) {   plot_RG(RG_to_igraph(RGs[[i]], gs, ts_per_gs), vertex.size = 20)   box() }  # Generate infection colours in order to add a legend infection_colours <- RColorBrewer::brewer.pal(n = 8, \"Set2\")   # Add a legend legend(\"bottomright\", pch = 21, pt.bg = infection_colours[unique(ts_per_gs)],         bty = \"n\", legend = names(y), title = \"Episode\") sorted_lliks <- sort(lliks, decreasing = T) # Sort log likelihoods adj_equal <- abs(diff(sorted_lliks, lag = 1)) < .Machine$double.eps^0.5 # Find matches decr_idxs <- which(adj_equal == FALSE) # Change points: 2, 8, 14, 20, 32, ... class_sizes <- c(decr_idxs[1], diff(decr_idxs)) # Number of graphs per class  # log likelihood of representative from each 'equivalence class' (EC) lliks_unique <- sorted_lliks[decr_idxs]  # EC likelihood class_ps <- exp(lliks_unique)*class_sizes max_class_p <- which(class_ps == max(class_ps)) # ML EC index  max_idx <- decr_idxs[max_class_p] # Index of last graph in ML EC max_size <- class_sizes[max_class_p] # Number of graphs in ML EC  # Plot all graphs within the ML EC  par(mar = rep(0.1,4), mfrow = c(3,4)) RG_order <- order(lliks, decreasing = T) # order RGs by logl for(i in (max_idx-max_size+1):max_idx) { # EC consists of the RGs with logl rank 21-32   RG <- post$RGs[[RG_order[i]]]   RG_igraph <- RG_to_igraph(RG, gs, ts_per_gs)   plot_RG(RG_igraph, vertex.size = 25, vertex.label = NA)   box() }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"example-of-a-group-of-four-intra-episode-siblings-collapsing-to-two","dir":"Articles","previous_headings":"","what":"Example of a group of four intra-episode siblings collapsing to two","title":"Explore treatment of intra-episode siblings","text":"showing groups intra-episode siblings collapse pairs intra-episode siblings, write function simulate data given allelic richness (marker cardinality) enrolment episode comprising stranger plus group four siblings, two one oocyst, two another, drawing two unrelated parental genotypes, recurrence one sibling. Technically, enrolment episode contains five genetically distinct genotypes thus MOI five. However, MOI estimates based maximum per-marker allele counts three one markers polyallelic: two one markers biallelic: Suppose estimate MOIs 3 1 biallelic data using external software exploits heteroallelic marker counts (rather maximum number per-marker alleles), input external estimates compute_posterior. Providing data simulated large number markers (200 ), recover almost exactly posterior probabilities using polyallelic data without user-specified MOIs biallelic data user-specified MOIs three one However, given polyallelic data likelihoods following graphs cliques three intra-episode siblings zero:  Whereas, relationships non-zero likelihoods given biallelic data:","code":"simulate_data <- function(marker_cardinality){      # Magic numbers / quantities   set.seed(5) # For reproducibility   n_markers <- 200 # Number of markers   n_strangers <- 3 # Number of stranger parasites   n_oocysts <- 2 # Number of oocysts to draw from      # Derived quantities   alleles <- letters[1:marker_cardinality]   markers <- paste0(\"m\", 1:n_markers) # Marker names      # Uniform allele frequencies    fs <- sapply(markers, simplify = FALSE,                 function(m) setNames(rep(1/marker_cardinality, marker_cardinality), alleles))      # Sample strangers   strangers <- sapply(1:n_strangers, function(i) {     sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))   })      # Designate strangers   parents <- strangers[, 1:2]      # Map the markers to chromosomes. Assume equally sized chromosomes — reasonable   # if and only if we later assume an equal number of crossovers per chromosome   chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))      # Sample parental allocations dependently per-oocyst    cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))      # Construct children from parental allocations    all_children <- lapply(1:n_oocysts, function(o) {     oocyst_chidren <- sapply(1:n_markers, function(i) {       sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])     })     colnames(oocyst_chidren) <- markers     return(oocyst_chidren)   })      # Make enrolment infection   enrol <- apply(rbind(all_children[[1]][1:2,],                         all_children[[2]][1:2,],                         strangers[,3]), 2, unique, simplify = F)      # Make paired data   data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))      return(list(data = data, fs = fs)) } polyallelic <- simulate_data(10)  determine_MOIs(polyallelic$data) #> [1] 3 1 biallelic <- simulate_data(2)  determine_MOIs(biallelic$data) #> [1] 2 1 ppost <- suppressMessages(compute_posterior(y = polyallelic$data,                                              fs = polyallelic$fs,                                              return.logp = T)) bpost <- suppressMessages(compute_posterior(y = biallelic$data,                                              fs = biallelic$fs,                                              MOIs = c(3,1), return.logp = T))  ppost$marg #>               C         L             I #> recur 0.6666667 0.3333333 2.708985e-116 bpost$marg #>               C         L            I #> recur 0.6666663 0.3333337 4.625927e-18 llikes <- sapply(bpost$RGs, function(RG) RG$logp) # Extract log likelihoods any(is.infinite(llikes)) # Are there any minus infinity log likelihoods? #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"contribution-to-upper-bounds","dir":"Articles","previous_headings":"","what":"Contribution to upper bounds","title":"Explore treatment of intra-episode siblings","text":"summation graphs cliques three siblings possibly redundant given graphs practical support. Even graphs zero likelihood, contribute maximum probabilities recrudescence / reinfection conditionally uniform prior graphs. However, upper bounds probability reinfection / recrudescence given single recurrence contribution small, especially reinfection:  recrudescence, 3 MOI vectors (circled ) result absolute difference greater 0.0175. feature large MOIs (MOI vectors 52, 62, 71) thus whose graph spaces include graphs largest cliques intra-episode siblings.  contribution likely smaller vectors three MOIs computationally feasible Pv3Rs constituent MOIs necessarily less 7 (computationally feasible MOI vectors total genotype count eight).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"summary-of-contents","dir":"Articles","previous_headings":"","what":"Summary of contents","title":"Understand posterior estimates","text":"vignette document output compute_posterior statistical model underpinning well specified misspecified. Specifically, document output compute_posterior model well specified data missing, data uninformative, data limited one episode, data incomparable across episodes, data limited one marker. model well specified data many markers, show maximum probability recrudescence / reinfection depends per-episode genotype counts (.e., multiplicities infections, MOIs), episode count, position recurrence sequence episodes, thus comment dependencies impact interpretation uncertainty. Finally, summarise results output compute_posterior model misspecified meiotic siblings, half siblings, parent child-like siblings, genotyping errors de novo mutations [-]. detailed result, see [development files Pv3Rs source package] (https://github.com/aimeertaylor/Pv3Rs/tree/main/DevFiles/RelationshipStudy). characterised model misspecification due inbred parasites. Allele frequency estimates encode population-level relatedness locus--locus (Mehra et al. 2025). Allele frequency estimates plugged statistical model underpinning Pv3Rs. Providing computed sample drawn parasite population trial participants also draw, need compensate elevated relatedness locus--locus population level. However, inter-locus dependence (linkage disequilibrium) liable generate overconfident posterior probabilities. Population structure (e.g., household effects) lead misclassification reinfection relapse / recrudescence. view, recurrence classification presence population structure best understood using complementary population genetic sensitivity analyses.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"missing-data","dir":"Articles","previous_headings":"","what":"Missing data","title":"Understand posterior estimates","text":"data entirely missing, compute_posterior returns prior. data missing user provides MOIs incompatible recrudescence, compute_posterior returns prior re-weighted exclusion recrudescence.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg  #>       C   L   I #> recur 0 0.5 0.5"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"uniformative-data","dir":"Articles","previous_headings":"","what":"Uniformative data","title":"Understand posterior estimates","text":"data entirely uninformative genetic diversity, compute_posterior returns prior.","code":"fs = list(m1 = c(\"A\" = 1)) # Unit allele frequency: no genetic diversity y = list(list(m1 = \"A\"), recur = list(m1 = \"A\")) # Data: not missing suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"homoallelic-data-without-user-specified-mois-prior-return","dir":"Articles","previous_headings":"Data on only one episode","what":"Homoallelic data without user-specified MOIs: prior return","title":"Understand posterior estimates","text":"one episode homoallelic data user specify MOI > 1, compute_posterior returns prior.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y <- list(enrol = list(m1 = NA), recur1 = list(m1 = \"A\")) # No enrolment data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>                C         L         I #> recur1 0.3333333 0.3333333 0.3333333"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"heteroallelic-data-prior-proximity","dir":"Articles","previous_headings":"Data on only one episode","what":"Heteroallelic data: prior proximity","title":"Understand posterior estimates","text":"one episode heteroallelic data, MOI model necessarily exceeds one model assumes false positivity. posterior close prior equal data slightly informative: relationship graphs intra-episode siblings, heteroallelic data limit summation identity--descent partitions partitions least two cells episode data. lower bound cell count increases number distinct alleles observed.","code":"# Allele frequencies  fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25))   # MOI at enrolment increases with number of observed alleles:   yMOI2 <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) yMOI3 <- list(enrol = list(m1 = c('A','B','C')), recur = list(m1 = NA)) yMOI4 <- list(enrol = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)) ys <- list(yMOI2, yMOI3, yMOI4) do.call(rbind, lapply(ys, function(y) {   suppressMessages(compute_posterior(y, fs))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3260870 0.3478261 0.3260870 #> recur 0.3248359 0.3503282 0.3248359  # MOI increases with external input: MOIs <- list(c(2,1), c(2,2), c(3,2)) # user-specified MOIs y <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data  do.call(rbind, lapply(MOIs, function(x) {   suppressMessages(compute_posterior(y, fs, MOIs = x))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3250000 0.3500000 0.3250000 #> recur 0.3334508 0.3330983 0.3334508"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"rare-homoallelic-data-with-user-specified-mois-exceeding-1-prior-departure","dir":"Articles","previous_headings":"Data on only one episode","what":"Rare homoallelic data with user-specified MOIs exceeding 1: prior departure","title":"Understand posterior estimates","text":"data homoallelic, user specifies MOIs greater one, observed allele rare, posterior departs prior rare intra-episode allelic repeats probable given relationship graphs intra-episode relatedness.  per-graph likelihood appreciable relationship graphs distinct parasite genotypes first episode siblings","code":"y <- list(enrol = list(m1 = 'A'), recur = list(m1 = NA)) # Homoallelic data MOIs <- list(c(2,1), c(3,2), c(5,1)) # Different MOIs with first MOI > 1 fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99)) # Rare observed allele"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-are-incomparable-across-episodes","dir":"Articles","previous_headings":"","what":"Data are incomparable across episodes","title":"Understand posterior estimates","text":"data multiple episodes comparable data across episodes, compute_posterior behaves similarly data limited one episode: returns prior data homoallelic without user-specified MOIs > 1, output remains close prior data heteroallelic, output departs prior data homoallelic rare user-specified MOIs > 1.","code":"# Allele frequencies fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99),            m2 = c(\"A\" = 0.01, \"B\" = 0.99))   # Data with an incomparable homoallelic call y_hom <- list(enrol = list(m1 = \"A\", m2 = NA),                recur = list(m1 = NA, m2 = \"A\"))  # Data with an incomparable heteroallelic call y_het <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = NA),                recur = list(m1 = NA, m2 = c(\"A\", \"B\")))   suppressMessages(compute_posterior(y_hom, fs))$marg # Prior return  #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y_het, fs))$marg # Prior proximity #>               C         L         I #> recur 0.3370787 0.3595506 0.3033708 suppressMessages(compute_posterior(y_hom, fs, MOIs = c(2,2)))$marg # Prior departure #>               C         L        I #> recur 0.5142862 0.2183909 0.267323"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-only-one-marker","dir":"Articles","previous_headings":"","what":"Data on only one marker","title":"Understand posterior estimates","text":"data single marker comparable across episodes, output compute_posterior depends observation type frequencies observed alleles. example, rare match informative: quashes posterior probability reinfection. partial rare match also informative, quashing posterior probability reinfection. match common allele informative: states possible posteriori. partial match common allele informative: states possible posteriori. mismatch informative: quashes posterior probability recrudescence. latter demonstrates sensitivity recrudescence inference assumption model genotyping errors: genotyping error generates single mismatch, posterior probability recrudescence quashed.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-only-two-markers","dir":"Articles","previous_headings":"","what":"Data on only two markers","title":"Understand posterior estimates","text":"data second marker added second observation consistent first strength inference generally increases (see arrows entering regions posterior probability greater 0.5); exception addition common match common partial match, informative (central arrow). mismatch added rare match (diamond), relapse becomes probable state. demonstrates requirement multiple markers relapse inference.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-many-markers","dir":"Articles","previous_headings":"","what":"Data on many markers","title":"Understand posterior estimates","text":"Given non-zero prior probabilities, data increase number markers genotyped, posterior probabilities given recurrence converge either relapse posterior probability one data suggest episode interest linked previous episodes regular sibling relationships recrudescence posterior probability less one data suggest episode interest linked previous episode clonal relationships reinfection posterior probability less one data suggest episode interest linked previous episodes regular sibling clonal relationships Recrudescence / reinfection probabilities necessarily converge uncertain values genetic data compatible recrudescence / reinfection also compatible relapse.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"posterior-bounds","dir":"Articles","previous_headings":"Data on many markers","what":"Posterior bounds","title":"Understand posterior estimates","text":"assume priori relationship graphs compatible given recurrent state sequence uniformly distributed, relationship graphs compatible sequences recrudescence / reinfection subset compatible sequences relapse, bounds induced prior non-marginal posterior probabilities can computed priori function prior recurrent state sequences prior relationship graphs; see vignette(“graph-prior”). probability mass function uniformly distributed discrete random variable depends size support, prior uniformly distributed graphs (thus bounds posterior induced prior) depends size graph space. Graph space size depends constitute graph size (graphs within space size). Graphs many vertices parasite genotypes within across episodes. , graph size depends episode counts per-episode MOIs, vary across trial participants. Using rare matched mismatched data 100 markers, demonstrate dependency per-episode MOIs prior-induced posterior bounds single recurrence. also demonstrate maximum marginal probabilities recrudescence / relapse depend episode counts adding recurrences recurrent data. However, maxima based knowledge recurrent data first recurrence. words, computable priori.","code":"marker_count <- 100 # Number of markers ms <- paste0(\"m\", 1:marker_count) # Marker names  all_As <- sapply(ms, function(t) \"A\", simplify = F) # As for all markers all_Bs <- sapply(ms, function(t) \"B\", simplify = F) # Bs for all markers no_data <- sapply(ms, function(t) NA, simplify = F) # NAs for all markers fs <- sapply(ms, function(m) c(\"A\" = 0.01, \"B\" = 0.99), simplify = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"increasing-per-episode-mois","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing per-episode MOIs","title":"Understand posterior estimates","text":"posterior probabilities recrudescence increase increasing graph size MOIs balanced. posterior probabilities reinfection increase increasing graph size.","code":"MOIs <- list(c(1,1), c(2,1), c(2,2))  y_match <- list(enrol = all_As, recur = all_As) y_mismatch <- list(enrol = all_As, recur = all_Bs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"digression-counts-of-intra-episode-siblings","dir":"Articles","previous_headings":"Data on many markers > Increasing per-episode MOIs","what":"Digression: counts of intra-episode siblings","title":"Understand posterior estimates","text":"increase per-episode MOIs, can increase user-specified MOIs without changing data, can increase allelic diversity data, s.t. MOIs modelled Pv3Rs increase without user-specified MOIs. Either way, get maximum probabilities: graph likelihoods change:  homoallelic data elevated user-specified MOIs, intra-episode parasites maximum likelihood graphs siblings. heteroallelic data, intra-episode parasites maximum likelihood graphs strangers. maximum probabilities recrudescence. One upshot maximum probabilities increased increasing counts intra-episode siblings. Arguably, maximum probabilities increase two intra-episode siblings siblings independent. practice, MOIs Pv3Rs model based realistic MOI estimates, groups three siblings modelled groups two; see vignette(“intra-episode-siblings”). END DIGRESSION","code":"all_ACs <- sapply(ms, function(t) c(\"A\", \"C\"), simplify = F) # A&C for all  all_BEs <- sapply(ms, function(t) c(\"B\", \"E\"), simplify = F) # A&C for all  all_ACDs <- sapply(ms, function(t) c(\"A\", \"C\", \"D\"), simplify = F) # A&C for all  fs <- sapply(ms, function(m) c(\"A\" = 0.01, \"B\" = 0.01, \"C\" = 0.01,                                 \"D\" = 0.01, \"E\" = 0.96), simplify = FALSE)  hom_match_data <- list(enrol = all_As, hom_match_data = all_As) het_match_data <- list(enrol = all_ACDs, het_match_data = all_ACs) hom_mismatch_data <- list(enrol = all_As, hom_mismatch_data = all_Bs) het_mismatch_data <- list(enrol = all_ACDs, het_mismatch_data = all_BEs)  rbind(suppressMessages(compute_posterior(hom_match_data, fs, MOIs = c(3,2))$marg),        suppressMessages(compute_posterior(het_match_data, fs)$marg),        suppressMessages(compute_posterior(hom_mismatch_data, fs, MOIs = c(3,2))$marg),       suppressMessages(compute_posterior(het_mismatch_data, fs)$marg)) #>                           C          L             I #> hom_match_data    0.8514851 0.14851485 9.084162e-231 #> het_match_data    0.8514851 0.14851485  0.000000e+00 #> hom_mismatch_data 0.0000000 0.05494505  9.450549e-01 #> het_mismatch_data 0.0000000 0.05494505  9.450549e-01"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"increasing-episode-counts","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing episode counts","title":"Understand posterior estimates","text":"Recurrences can added without adding data marginal probability first recurrence recrudescence / reinfection depends total number recurrences:  example recrudescence probabilities converge maxima 1, 2, 5 100 markers:  Note maxima bounds imposed prior: based knowledge recurrent data first recurrence; see vignette(“graph-prior”).","code":"ys_match <- list(\"1_recurrence\" = list(enrol = all_As,                                         recur1 = all_As),                  \"2_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data),                  \"3_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data,                                        recur3 = no_data))  ys_mismatch <- list(\"1_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs),                     \"2_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data),                     \"3_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data,                                           recur3 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"position-in-a-sequence","dir":"Articles","previous_headings":"Data on many markers","what":"Position in a sequence","title":"Understand posterior estimates","text":"distribution relationship graphs invariant different orderings states sequence (graphs compatible reinfection beginning versus end sequence three episodes, example), position recurrence sequence bearing posterior estimates. effect negligible episodes data many markers: Instead, consider sequences episodes observations (Os) episodes data (Ns):","code":"y <- list(enrol = all_As,            recur1 = all_As,            recur2 = all_As,            recur3 = all_As) suppressMessages(compute_posterior(y, fs))$marg #>                C         L            I #> recur1 0.7720588 0.2279412 5.585675e-23 #> recur2 0.7720588 0.2279412 5.316220e-23 #> recur3 0.7720588 0.2279412 5.044004e-23 ys_match <- list(\"NOO\" = list(enrol = no_data,                                recur1 = all_As,                               recur2 = all_As),                  \"ONO\" = list(enrol = all_As,                                recur1 = no_data,                               recur2 = all_As),                  \"OON\" = list(enrol = all_As,                                recur1 = all_As,                               recur2 = no_data))  ys_mismatch <- list(\"NOO\" = list(enrol = no_data,                                   recur1 = all_As,                                  recur2 = all_Bs),                     \"ONO\" = list(enrol = all_As,                                   recur1 = no_data,                                  recur2 = all_Bs),                      \"OON\" = list(enrol = all_As,                                   recur1 = all_Bs,                                  recur2 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"highly-informed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Highly informed recurrences","title":"Understand posterior estimates","text":"first recurrence sequence OON (upward purple 1 triangle) slightly lower probability recrudescence second recurrence sequence NOO (upward green 2 triangle) despite recurrences rare observations match directly preceding episode. first recurrence sequence OON (downward purple 1 triangle) slightly higher probability reinfection second recurrence sequence NOO (downward green 2 triangle) despite recurrences observations mismatch directly preceding episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"weakly-and-uninformed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Weakly and uninformed recurrences","title":"Understand posterior estimates","text":"Unsurprisingly, posterior first recurrence sequence NOO close prior (preceding data), likewise second recurrence sequence OON (data). surprisingly, posterior first recurrence sequence ONO close prior, despite data. closer inspection, surprising reasons explained . match data (upward triangles), strong evidence clonal edge episodes one three ONO incompatible recurrence sequences ending reinfection reinfection followed recrudescence, informing strongly second recurrence weakly first recurrence. comparison, strong evidence clonal edge episodes two three NOO incompatible sequences recurrences ending reinfection, informing second recurrence ; likewise, strong evidence clonal edge episodes one two OON incompatible sequences recurrences starting reinfection, informing first recurrence . close inspection upward orange 1 triangle makes intuitive sense: know first recurrence followed second MOI = 1 recurrence clone MOI = 1 enrolment episode, unlikely second recurrence clone drawn new mosquito recrudescence reinfection. , data enrolment episode second recurrence tell us something first recurrence, thus posterior estimate first recurrence deviates prior even though first recurrence data. explanation mismatch data (downward triangles) sequence ONO similar match data: strong evidence stranger edge episodes one three incompatible double recrudescence, posterior first recurrence (downward orange 1 triangle) deviates prior despite first recurrence data.","code":"epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_match[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"IL\" \"II\" epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"CC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"LC\" \"IC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"CL\" \"CI\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"interpreting-uncertainty","dir":"Articles","previous_headings":"","what":"Interpreting uncertainty","title":"Understand posterior estimates","text":"Uncertain posterior estimates can uncertain two reasons mutually exclusive: data needed states fully identifiable also important bear mind fact , Pv3Rs model, trial participants different epside counts per-episode MOIs different maximum probabilities recrudescence / reinfection. example, use common threshold 0.8 classify probable reinfection assuming recurrence states equally likely priori, can discount priori trail participants single monoclonal recurrence following monoclonal enrolment episode posterior reinfection probabilities never exceed 0.75, even data highly informative reinfection: , given trial participant, probability recrudescence / reinfection depends position within sequence, especially one episodes data.","code":"y <- list(enrol = all_As, recur = all_Bs) fs <- sapply(ms, FUN = function(m) c(\"A\" = 0.5, \"B\" = 0.5), simplify = FALSE)  # Using the default uniform prior on recurrent states suppressMessages(compute_posterior(y, fs))$marg #>       C    L    I #> recur 0 0.25 0.75  # Using a non-uniform prior on recurrent states prior <- as.matrix(data.frame(\"C\" = 0.25, \"L\" = 0.25, \"I\" = 0.5)) suppressMessages(compute_posterior(y, fs, prior))$marg #>       C         L         I #> recur 0 0.1428571 0.8571429"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods","dir":"Articles","previous_headings":"Meiotic siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data generated results initial infection containing two three meiotic siblings recurrent stranger clone regular sibling meiotic sibling Posterior probabilities computed assuming recurrent states equally likely priori.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results","dir":"Articles","previous_headings":"Meiotic siblings","what":"Results","title":"Understand posterior estimates","text":"initial infection contains two meiotic siblings compute_posterior well behaved maximum likelihood true relationship graph (shown). Posterior probabilities converge probable reinfection recurrent parasite stranger, probable recrudescence recurrent parasite clone, certain relapse recurrent parasite regular sibling, certain relapse recurrent parasite meiotic sibling.  initial infection contains three meiotic siblings recurrent parasite either stranger clone, posterior probabilities converge correctly probable reinfection probable recrudescence, respectively, maximal values given graphs relationships two, three, parasites initial infection.  Relationship graphs (shown) wrong two reasons: relationship graphs two, three, parasites initial infection two alleles per marker. Although technically incorrect, behaviour arguably desirable (see digression ). highest likelihood relationship graphs stranger parasites initial episode prevalence data three four meiotic siblings identical bulk data parents strangers. can force graphs three distinct parasites initial episode specifying external MOIs. recovers maximum likelihood true relationship graphs. However, correct MOIs unknowable practice: collection siblings two parents can ever diverse two parents. initial infection contains three meiotic siblings recurrent parasite regular meiotic sibling, posterior probabilities converge probable recrudescence maximum likelihood graphs clonal edge sibling relapse, either two stranger parasites initial episode external MOIs specified, three sibling parasites initial episode correct MOIs (unknowable practice) provided externally.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods-1","dir":"Articles","previous_headings":"Half siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data three half siblings: two initial episode, third recurrence: child parents 1 2 initial episode child parents 1 3 initial episode child parents 2 3 recurrence explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results-1","dir":"Articles","previous_headings":"Half siblings","what":"Results","title":"Understand posterior estimates","text":"general, parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped. particular case three equifrequent alleles per marker, can show theoretically system behaves erratically small perturbation ratio observations (alleles match across three half siblings, alleles different, intra-episode alleles match, inter-episode alleles match) can lead large deviation odds relapse versus reinfection; see vignette(“half-siblings”). purple, red, green trajectories higher expected 0.5 intra--inter match ratios; moreover, purple trajectory’s intra--inter match ratio consistently exceeds 0.5×log2(25)0.5\\times \\text{log}_2(\\dfrac{2}{5}), condition found theoretically concentrate posterior probability reinfection certain conditions; , see vignette(“half-siblings”). intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped. scenarios, likelihood true graph siblings within across episodes quashed soon distinct alleles three parents observed given marker. general, parasites draw allele distribution, maximum likelihood graphs two one inter-episode sibling edge. intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods-2","dir":"Articles","previous_headings":"Parent-child like siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data three parent-child like siblings: child selfed parent 1 initial episode child parents 1 2 initial episode child selfed parent 2 recurrence Aside: alternative children selfed parents initial episode equivalent meiotic case three mieotic siblings initial episode prevalence data three meiotic siblings equivalent prevalence data two stranger parents leads probable recrudescence rather certain relapse number markers genotyped. half-siblings, explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results-2","dir":"Articles","previous_headings":"Parent-child like siblings","what":"Results","title":"Understand posterior estimates","text":"parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped.  intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped.  general, parasites draw allele distribution, maximum likelihood graph true graph siblings within across episodes. Meanwhile, intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aimee Taylor. Author, maintainer. Yong See Foo. Author. European Union, Project 101110393 — PvRecur. Funder.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor , Foo Y (2025). Pv3Rs: Estimate cause recurrent vivax malaria using genetic data. R package version 0.0.0.9000, https://github.com/aimeertaylor/Pv3Rs.","code":"@Manual{,   title = {Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data},   author = {Aimee Taylor and Yong See Foo},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/aimeertaylor/Pv3Rs}, }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pv3rs","dir":"","previous_headings":"","what":"Estimate the cause of recurrent vivax malaria using genetic data","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"R package developed enable statistical genetic inference Plasmodium vivax Relapse Reinfection Recrudescence main function Pv3Rs::compute_posterior can used estimate posterior probabibilities relapse, reinfection recrudescence one recurrence using genetic data update prior, ideally informative (e.g., based time--event information). features general: Pv3Rs::plot_data can used visualise genetic data molecular correction regardless analytical method (e.g., used visualise Plasmodium falciparum data intended analysis using match counting algorithm). Together, Pv3Rs::plot_simplex Pv3Rs::project2D can used plot vector three numbers 0 1 sum one.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"unstable-state","dir":"","previous_headings":"Please be aware of the following points!","what":"Unstable state:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"R package currently development thus liable contain many errors. model around Pv3Rs R package developed documented preprint [1]. model builds upon prototype documented [2] (see [1] better understand model underpinning Pv3Rs differs prototype). [1] Taylor, Foo & White, 2022 [2] Taylor & Watson et al. 2019","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"prior-considerations","dir":"","previous_headings":"Please be aware of the following points!","what":"Prior considerations:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Genetic data modelled using Bayesian model, whose prior ideally informative ([2] prior estimates generated time--event model built James Watson) cause recurrent P. vivax malaria always identifiable genetic data alone (data consistent recurrent parasites relatively unrelated preceding infections, reinfection relapse plausible; meanwhile, data compatible recurrent parasites clones preceding infection, recrudescence relapse plausible). main Pv3Rs function, compute_posterior(), used estimate probable cause recurrent P. falciparum malaria setting prior probability relapse zero. However, current version Pv3Rs suboptimal P. falciparum recurrent state inference: genotyping errors, accounted current Pv3Rs model, liable lead misclassification recrudescence reinfection probability relapse zero priori.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"notable-assumptions","dir":"","previous_headings":"Please be aware of the following points!","what":"Notable assumptions:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Relationship graphs compatible given recurrent state sequence equally likely priori Perfect detection alleles (genotyping error) Perfect detection parasites (problematic low density clones) Perfect detection episodes (requires active follow ) Mutually exclusive recurrent states (requires frequent follow treatment) within-host de novo mutations Parasites outbred (implies parasite population infinitely large panmitic) Ignores long-range linkage disequilibrium due background relatedness Ignores short-range linkage disequilbrium sibling parasites Siblings transitive (true parent child-like sibling trios) Siblings independent (true meiotic siblings) Siblings draw two parents (true half-siblings) first assumption listed small artefactual effect posterior estimates relationship graphs grow size. demonstrated one examples Pv3Rs::compute_posterior() explained detail upcoming vignette. studies possibly high rates recrudescence, recommend sensitivity analysis explore impact genotyping errors recrudescence. example provided upcoming vignette. marker independence assumption liable lead overconfident posterior probabilities markers linked.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"computational-limits","dir":"","previous_headings":"Please be aware of the following points!","what":"Computational limits:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Pv3Rs scales 100s markers whole-genome sequence (WGS) data. recommend running Pv3Rs::compute_posterior() data whose total genotype count (sum per-episode multiplicities infection) exceeds eight. total genotype counts exceeds eight multiple recurrences, might possible generate recurrent state estimates recurrences one--one (approach used [2]). tested per-marker allele limit Pv3Rs::compute_posterior(). high marker cardinalities lead small allele frequencies thus underflow problems.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"population-level-allele-frequencies","dir":"","previous_headings":"Please be aware of the following points!","what":"Population-level allele frequencies","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"compute_posterior() requires population-level alelle frequencies. avoid bias due within-host selection recrudescent parasites, recommended using enrolment episodes estimate population-level allele frequencies. said, recurrences either reinfections relapses, draws mosquito population (albeit delayed draw case relapse), absence systematic within-patient selection (might occur break-infections encounter lingering drug pressure), estimates based episodes unbiased precise based enrolment episodes .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"other-points","dir":"","previous_headings":"Please be aware of the following points!","what":"Other points:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Unfortunately, Pv3Rs model exploit read count data present. However, read count data used compute population-level allele frequencies, assuming biased experimental artefacts.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"","code":"# Install or update latest stable version of devtools from CRAN # I highly recommend doing this if you've recently updated R and RStudio to versions 4.3.0 and 2023.3.1.446, respectively;  # otherwise, you might encounter problems rendering documentation install.packages(\"devtools\")  # Install R.rsp, a vignette builder used to build LaTeX vignettes in Pv3Rs install.packages(\"R.rsp\")  # Install Pv3Rs from GitHub  # I highly recommend doing this in RStudio as RStudio installs pandoc needed to build vignettes # If you're working in R outside of RStudio you might need to install pandoc and check its path;  # otherwise set build_vignettes = FALSE devtools::install_github(\"aimeertaylor/Pv3Rs\", build_vignettes = TRUE)  # Load and attach the package library(Pv3Rs)  # View documentation and examples for main function ?compute_posterior  # Load the demo vignette vignette(\"demo\", package = \"Pv3Rs\")  # Lists available functions, as well as example data sets and their documentation [check] help(package = \"Pv3Rs\")"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","title":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","text":"Estimate per-person posterior probabilities recurrent Plasmodium vivax (Pv) infection recrudescence, relapse, reinfection (3Rs) using per-person P. vivax genetic data two infections.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","text":"Maintainer: Aimee Taylor aimee.taylor@pasteur.fr (ORCID) Authors: Yong See Foo contributors: European Union, Project 101110393 — PvRecur [funder]","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_inference.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the likelihood of all relationship graphs — RG_inference","title":"Computes the likelihood of all relationship graphs — RG_inference","text":"likelihood relationship graph (RG) can decomposed markers, assume marker data conditionally independent across markers given RG. likelihood RG one marker found integrating possible IBD (identity--descent) partitions consistent RG. probability distribution IBD partitions always uniform. Since different RGs may use IBD, likelihood IPs marker stored hash tables improved computational efficiency.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_inference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the likelihood of all relationship graphs — RG_inference","text":"","code":"RG_inference(MOIs, fs, alleles_per_m)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_inference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the likelihood of all relationship graphs — RG_inference","text":"MOIs numeric vector specifying, infection, number distinct parasite genotypes, .k.. multiplicity infection (MOI). fs List allele frequencies vectors. Names list must match marker names alleles_per_m. alleles_per_m List allele assignments dataframes marker. column corresponds genotype row corresponds allele assignment.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_inference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the likelihood of all relationship graphs — RG_inference","text":"List relationship graph objects, including log-likelihoods variable object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_inference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the likelihood of all relationship graphs — RG_inference","text":"","code":"# 1 marker, 2 infections, MOIs = 2, 1 MOIs <- c(2, 1) fs <- list(   m1 = stats::setNames(c(0.4, 0.6), c(\"A\", \"B\")),   m2 = stats::setNames(c(0.2, 0.8), c(\"C\", \"D\")) ) al_df1 <- as.data.frame(matrix(c(\"A\", \"B\", \"B\"), nrow = 1)) al_df2 <- as.data.frame(matrix(c(   \"C\", \"D\", \"C\",   \"D\", \"C\", \"C\" ), nrow = 2, byrow = TRUE)) colnames(al_df1) <- colnames(al_df2) <- paste0(\"g\", 1:3) alleles_per_m <- list(m1 = al_df1, m2 = al_df2) RGs <- RG_inference(MOIs, fs, alleles_per_m) #> Number of valid relationship graphs (RGs) is 9 #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #> Computing log p(Y|RG) for 9 RGs #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> |"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts relationship graph to an igraph object — RG_to_igraph","title":"Converts relationship graph to an igraph object — RG_to_igraph","text":"Converts relationship graph igraph object","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts relationship graph to an igraph object — RG_to_igraph","text":"","code":"RG_to_igraph(RG, gs, ts_per_gs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts relationship graph to an igraph object — RG_to_igraph","text":"RG Relationship graph output enumerate_RGs igraph=FALSE. gs Vector genotype names. ts_per_gs Vector infection numbers genotype. can inferred data y using rep(1:length(y), determine_MOIs(y)).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts relationship graph to an igraph object — RG_to_igraph","text":"igraph object along original variables RG.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts relationship graph to an igraph object — RG_to_igraph","text":"","code":"set.seed(20) RG <- sample_RG(c(2, 2)) RG <- RG_to_igraph(RG, c(\"g1\", \"g2\", \"g3\", \"g4\"), c(1, 1, 2, 2))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compatible_rstrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","title":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","text":"Finds possible recurrence states recurrence compatible relationship graph, takes Cartesian product get vectors recurrence states. recurrence recrudescence, edges recurrent infection immediately preceding infection must clonal edges. recurrence reinfection, edges recurrent infection preceding infection must stranger edges. recurrences may possibly relapses.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compatible_rstrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","text":"","code":"compatible_rstrs(RG, gs_per_ts)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compatible_rstrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","text":"RG Relationship graph; see enumerate_RGs. gs_per_ts List vectors genotypes infection.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compatible_rstrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","text":"Vector strings (consisting \"C\", \"L\", \"\" recrudescence, relapse, reinfection respectively) compatible relationship graph.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compatible_rstrs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find all vectors of recurrence states compatible with relationship graph — compatible_rstrs","text":"","code":"MOIs <- c(2, 2, 1) RG <- enumerate_RGs(MOIs, igraph = TRUE)[[175]] #> Number of valid relationship graphs (RGs) is 250 #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | gs_per_ts <- split(paste0(\"g\", 1:sum(MOIs)), rep(1:length(MOIs), MOIs)) # 1st recurrence can't be recrudescence, 2nd recurrence can't be reinfection plot_RG(RG, edge.curved = 0.2)  compatible_rstrs(RG, gs_per_ts) # \"LL\" \"IL\" \"LC\" \"IC\" #> [1] \"LL\" \"IL\" \"LC\" \"IC\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"Compute posterior probabilities P. vivax recurrent states relapse, reinfection recrudescence using genetic data. Please note, progress bar necessarily increment uniformly (see details ); may seem stuck code still running.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"","code":"compute_posterior(   y,   fs,   prior = NULL,   MOIs = NULL,   return.RG = FALSE,   return.logp = FALSE )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"y Observed data form list lists. outer list list episodes increasing chronological order. inner list list named markers per episode. Episode names can specified, used. Markers must named. episode must list markers. markers typed per episode, data untyped markers can encoded missing (see ). marker, one must specify allelic vector: set distinct alleles detected marker. NAs encode missing per-marker data, .e., alleles observed given marker. NA entries allelic vectors contain NA non-NA entries ignored. Allele names arbitrary, must correspond frequency names (see examples ). names can used alleles belonging different markers. , frequencies must specified per named allele per named marker. fs List per-marker allele frequency vectors. Names list must match marker names y. Within lists (.e., marker), frequencies must specified per allele name. prior Matrix prior probabilities recurrence states recurrent episode. row corresponds episode increasing chronological order. column names must C, L, recrudescence, relapse reinfection respectively. Row names can specified used. prior NULL (default), per-episode recurrent states equally likely. MOIs Multiplicity infection episode. MOIs provided, parsimonious MOIs compatible data used; see determine_MOIs. return.RG Boolean whether return relationship graphs, defaults FALSE. return.logp set TRUE, return.RG overridden TRUE, log-probabilities returned relationship graph. return.logp Boolean whether return log-likelihood relationship graph, defaults FALSE. setting return.logp TRUE, return.RG also set TRUE. Setting return.logp FALSE allows permutation symmetries exploited save computational time, see enumerate_alleles. Setting TRUE result longer runtimes, especially multiplicities infection large. Note argument affect output posterior probabilities.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"List containing: marg Matrix marginal posterior probabilities recurrent states recurrence, one row per recurrence \"C\" recrudescence, \"L\" relapse, \"\" reinfection. marg simple summary joint (see next): marginal probability recurrent state sum subset joint probabilities recurrent state sequences. example, marginal probability \"C\" first two recurrences sum joint probabilities \"CC\", \"CL\", \"CI\". joint Vector joint posterior probabilities recurrent state sequence, within sequence \"C\" denotes recrudescence, \"L\" denotes relapse, \"\" denotes reinfection. RGs List relationship graphs log-likelihoods stored. returned return.RG TRUE. See enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"compute_posterior() computes posterior probabilities proportional likelihood multiplied prior. likelihood sums ways phase allelic data onto haploid genotypes graphs relationships haploid genotypes ways partition alleles clusters identity--descent compute_posterior() expects per-episode, per-marker allelic vector set distinct alleles. Allele repeats markers observed data, NA repeats markers missing data, removed data pre-processing step. NAs allelic vectors also contain non-NA values removed data pre-processing step. enumerate possible relationship graphs haploid genotypes, pairs genotypes can either clones, siblings, strangers. likelihood sequence recurrence states can determined likelihood relationship graphs compatible said sequence. details enumeration likelihood calculation relationship graphs can found enumerate_RGs RG_inference respectively. relationship graph, model sums possible identity--descent partitions. relationship graphs compatible identity--descent partitions others, log p(Y|RG) progress bar necessarily increment uniformly. Notable model assumptions limitations: Perfect detection alleles (genotyping error) within-host de novo mutations Parasites outbred siblings regular siblings Relationship graphs compatible given sequence recurrent states equally likely priori recommend running `compute_posterior() total genotype count (sum per-episode multiplicities infection) exceeds eight, many relationship graphs. Presently, Pv3Rs supports prevalence data (categorical data signal detection alleles), quantitative data (data signal proportional abundance alleles detected).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior probabilities of P. vivax recurrent states — compute_posterior","text":"","code":"# =========================================================================== # Example where alleles are named numerically # =========================================================================== # Data y <- list(enroll = list(m1 = c('3','2'), m2 = c('1','2')),           recur1 = list(m1 = c('1','4'), m2 = c('1')),           recur2 = list(m1 = c('1'), m2 = NA))  # Allele frequencies fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),            m2 = c('1' = 0.27, '2' = 0.73))  # Compute posterior probabilities using default prior compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 250 #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #> Computing log p(Y|RG) for 250 RGs #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #> Finding log-likelihood of each vector of recurrent states #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #>  #> $marg #>                C         L         I #> recur1 0.0000000 0.1949556 0.8050444 #> recur2 0.2938829 0.2476598 0.4584573 #>  #> $joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.05539481 0.23848807 0.00000000 0.05314490 0.19451493 0.00000000  #>         LI         II  #> 0.08641590 0.37204139  #>    # =========================================================================== # Example where alleles are named arbitrarily and probabilities are plotted # =========================================================================== # Data y <- list(episode0 = list(marker1 = c(\"Tinky Winky\", \"Dipsy\"),                           marker2 = c(\"Tinky Winky\", \"Laa-Laa\", \"Po\")),           episode1 = list(marker1 = \"Tinky Winky\",                           marker2 = \"Laa-Laa\"))  # Allele frequencies fs <- list(marker1 = c(\"Tinky Winky\" = 0.4, \"Dipsy\" = 0.6),            marker2 = c(\"Tinky Winky\" = 0.1, \"Laa-Laa\" = 0.1, \"Po\" = 0.8))  # Compute posterior probabilities using default prior posterior_probs <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 30 #> == #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> | #> Computing log p(Y|RG) for 30 RGs #> == #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> | #> Finding log-likelihood of each vector of recurrent states #> == #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> == #> === #> == #> === #> == #> === #> === #> | #>   # Plot posterior probabilities on the simplex plot_simplex(c(\"Recrudescence\", \"Relapse\", \"Reinfection\"), 0.5) # Simplex xy <- project2D(posterior_probs$marg[1,]) # Project probabilities points(x = xy[\"x\"], y = xy[\"y\"], pch = 20) # Plot projected probabilities    #============================================================================ # Demonstrating the return of the prior when all data are missing #============================================================================ # Data y_missing <- list(enroll = list(m1 = NA),                   recur1 = list(m1 = NA),                   recur2 = list(m1 = NA))  # Return of the prior suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)))) #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enroll & recur1 & recur2 have no data #> $marg #>                C         L         I #> recur1 0.3333333 0.3333333 0.3333333 #> recur2 0.3333333 0.3333333 0.3333333 #>  #> $joint #>        CC        LC        IC        CL        LL        IL        CI        LI  #> 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111 0.1111111  #>        II  #> 0.1111111  #>   # Return of the prior re-weighted to the exclusion of recrudescence suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)),                  MOIs = c(1,2,3))) #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enroll & recur1 & recur2 have no data #> $marg #>        C   L   I #> recur1 0 0.5 0.5 #> recur2 0 0.5 0.5 #>  #> $joint #>   CC   LC   IC   CL   LL   IL   CI   LI   II  #> 0.00 0.00 0.00 0.00 0.25 0.25 0.00 0.25 0.25  #>   # (Recrudescing parasites are clones of previous blood-stage parasites. The # Pv3R model assumes no within-host de-novo mutations and perfect allele # detection. As such, recrudescence is incompatible with an MOI increase on # the preceding infection.)   # =========================================================================== # Demonstrating the cosmetic-only nature of episode names # =========================================================================== # Data y <- list(enroll = list(m1 = NA),           recur2 = list(m1 = NA),           recur1 = list(m1 = NA))  # Use a non-uniform prior for the purpose of illustration prior <- matrix(c(0.2,0.2,0.6,0.7,0.1,0.2), byrow = TRUE, nrow = 2,                 dimnames = list(c(\"recur1_prior\", \"recur2_prior\"),                                 c(\"C\", \"L\", \"I\")))  # Print posterior and prior, noting that \"recur1_prior\" is returned for # \"recur2\", and \"recur2_prior\" is returned for \"recur1\" suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg #> Warning: Data and prior episode names disagree #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enroll & recur2 & recur1 have no data #>          C   L   I #> recur2 0.2 0.2 0.6 #> recur1 0.7 0.1 0.2 prior #>                C   L   I #> recur1_prior 0.2 0.2 0.6 #> recur2_prior 0.7 0.1 0.2   #============================================================================ # Demonstrating the informative nature of non-recurrent data #============================================================================ # Data and allele frequencies y_het <- list(list(m1 = c('1', '2')), list(m1 = NA)) y_hom <- list(list(m1 = '1'), list(m1 = NA)) fs = list(m1 = c('1' = 0.5, '2' = 0.5))  # The prior is not returned despite there being no recurrent data (see # vignette XXX to understand why) suppressMessages(compute_posterior(y = y_het, fs))$marg #> Warning: Markers m1 has data on one episode only #> Warning:  #>              C         L         I #> [1,] 0.3292683 0.3414634 0.3292683 suppressMessages(compute_posterior(y = y_hom, fs, MOIs = c(2,1)))$marg #> Warning: Markers m1 has data on one episode only #> Warning:  #>              C         L         I #> [1,] 0.3358209 0.3283582 0.3358209    #============================================================================ # Demonstrating the effect of increasingly large relationship graphs: the # marginal probability of the first recurrence changes slightly, albeit at a # decreasing rate, as the number of additional recurrences (all without data) # increases. The change is greatest when the observed allele is rare. #============================================================================ # Data for different recurrence counts where only the 1st recurrence has data ys <- list(scenario1 = list(enroll = list(m1 = \"A\"),                             recur1 = list(m1 = \"A\")),            scenario2 = list(enroll = list(m1 = \"A\"),                             recur1 = list(m1 = \"A\"),                             recur2 = list(m1 = NA)),            scenario3 = list(enroll = list(m1 = \"A\"),                             recur1 = list(m1 = \"A\"),                             recur2 = list(m1 = NA),                             recur3 = list(m1 = NA)),            scenario4 = list(enroll = list(m1 = \"A\"),                             recur1 = list(m1 = \"A\"),                             recur2 = list(m1 = NA),                             recur3 = list(m1 = NA),                             recur4 = list(m1 = NA)))  # Allele frequencies: smaller f_A leads to larger change f_A <- 0.1; fs <- list(m1 = c(\"A\" = f_A, \"Other\" = 1-f_A))  # Compute posterior probabilities and extract marginal probabilities results <- lapply(ys, function(y) compute_posterior(y, fs)$marg) #> Number of valid relationship graphs (RGs) is 3 #> ========================= #> ========================== #> ========================== #> | #> Computing log p(Y|RG) for 3 RGs #> ========================= #> ========================== #> ========================== #> | #> Finding log-likelihood of each vector of recurrent states #> ========================= #> ========================== #> ========================== #> | #>  #> Warning: Episode recur2 has no data #> Number of valid relationship graphs (RGs) is 12 #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ======= #> | #> Computing log p(Y|RG) for 12 RGs #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ======= #> | #> Finding log-likelihood of each vector of recurrent states #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ====== #> ======= #> ====== #> ======= #> ====== #> ======= #> | #>  #> Warning: Episodes recur2 & recur3 have no data #> Number of valid relationship graphs (RGs) is 60 #> = #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> | #> Computing log p(Y|RG) for 60 RGs #> = #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> | #> Finding log-likelihood of each vector of recurrent states #> = #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> = #> = #> = #> == #> = #> = #> == #> | #>  #> Warning: Episodes recur2 & recur3 & recur4 have no data #> Number of valid relationship graphs (RGs) is 358 #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #> Computing log p(Y|RG) for 358 RGs #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #> Finding log-likelihood of each vector of recurrent states #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> | #>   # Extract results for the first recurrence results_recur1 <- sapply(results, function(result) result[1,]) results_recur1 # Results are different for different scenarios #>    scenario1  scenario2  scenario3  scenario4 #> C 0.60606061 0.61538462 0.62294515 0.62925894 #> L 0.33333333 0.32307692 0.31476034 0.30781517 #> I 0.06060606 0.06153846 0.06229451 0.06292589  # Visualise the change in the marginal probability of the first recurrence plot_simplex(c(\"Recrudescence\", \"Relapse\", \"Reinfection\")) # Plot simplex xy <- apply(results_recur1, 2, project2D) # Project probabilities points(x = xy[\"x\", ], y = xy[\"y\", ], pch = \"-\", col = 1:4) # Plot projections legend(\"left\", col = 1:4, pch = \"-\", pt.cex = 2, bty = \"n\", legend = 1:4, title = \"Recurrence \\n count\") # legend"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine MOIs from unphased data — determine_MOIs","title":"Determine MOIs from unphased data — determine_MOIs","text":"MOIs returned correspond parsimonious explanation data, .e. minimal MOIs required support observed allelic diversity.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine MOIs from unphased data — determine_MOIs","text":"","code":"determine_MOIs(y)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine MOIs from unphased data — determine_MOIs","text":"y Observed data form list lists. outer list list episodes chronological order. inner list list named markers per episode. marker, one must specify allelic vector: set distinct alleles detected marker.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine MOIs from unphased data — determine_MOIs","text":"Returns vector (minimum) multiplicity infection (MOI) infection.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine MOIs from unphased data — determine_MOIs","text":"given episode, minimal MOI required support observed allelic diversity equal maximum number per-marker alleles observed across markers. present, Pv3Rs supports prevalence data (categorical data signal detection alleles), quantitative (proportional abundance) data. Allele repeats markers observed data, repeat NAs markers missing data, removed. NAs allelic vectors also contain non-NA values ignored.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine MOIs from unphased data — determine_MOIs","text":"","code":"# two infections, three markers y <- list(   list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),   list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\")) ) determine_MOIs(y) # should be c(2, 3) #> [1] 2 3"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_CPs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate clonal partitions — enumerate_CPs","title":"Enumerate clonal partitions — enumerate_CPs","text":"clonal partition partition genotypes pair genotypes partition cell clonal relationship. Genotypes infection clones. code enumerates clonal partitions, accounting intra-infection restriction; see vignette(\"enumerate\") details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_CPs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate clonal partitions — enumerate_CPs","text":"","code":"enumerate_CPs(MOIs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_CPs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate clonal partitions — enumerate_CPs","text":"MOIs numeric vector specifying, infection, number distinct parasite genotypes, .k.. multiplicity infection (MOI).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_CPs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate clonal partitions — enumerate_CPs","text":"list possible partitions, partition encoded membership vector, indices (genotype names) entry corresponding genotypes int partition cell.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_CPs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate clonal partitions — enumerate_CPs","text":"","code":"enumerate_CPs(c(2, 2)) #> [[1]] #> [1] 1 2 1 2 #>  #> [[2]] #> [1] 1 2 1 3 #>  #> [[3]] #> [1] 1 2 2 1 #>  #> [[4]] #> [1] 1 2 2 3 #>  #> [[5]] #> [1] 1 2 3 1 #>  #> [[6]] #> [1] 1 2 3 2 #>  #> [[7]] #> [1] 1 2 3 4 #>"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_IPs_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","title":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","text":"Enumerate IBD partitions consistent given relationship graph; see vignette(\"enumerate\") details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_IPs_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","text":"","code":"enumerate_IPs_RG(RG, compat = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_IPs_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","text":"RG relationship graph; see enumerate_RGs details. compat Logical, true, list partitions equivalence objects returned. Otherwise, returns list IBD partition vectors reference sibling clusters.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_IPs_RG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","text":"IBD partition consistent relationship graph given, must satisfy following: genotypes within IBD cell clonal sibling relationships , genotypes clones must IBD cell, cluster sibling units span 2 IBD cells (corresponds two parents). Note IBD partitions equally likely.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_IPs_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate IBD partitions consistent with a given relationship graph — enumerate_IPs_RG","text":"","code":"set.seed(3) RG <- sample_RG(c(2, 1, 2)) enumerate_IPs_RG(RG) #> [[1]] #> [1] {g1,g4,g5}{g2,g3} #>  #> [[2]] #> [1] {g1}{g4,g5}{g2,g3} #>  #> [[3]] #> [1] {g1,g4}{g5}{g2,g3} #>  #> [[4]] #> [1] {g1,g5}{g4}{g2,g3} #>  #> [[5]] #> [1] {g1,g4,g5}{g2}{g3} #>  #> [[6]] #> [1] {g1}{g4,g5}{g2}{g3} #>  #> [[7]] #> [1] {g1,g4}{g5}{g2}{g3} #>  #> [[8]] #> [1] {g1,g5}{g4}{g2}{g3} #>"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate relationship graphs — enumerate_RGs","title":"Enumerate relationship graphs — enumerate_RGs","text":"relationship graph complete graph genotypes (one per vertex), edge annotated clone, sibling, stranger edge. enumerated relationship graphs satisfy following constraints: subgraph induced clone edges cluster graph. subgraph induced clone edges sibling edges cluster graph. Clone edges allowed two genotypes different infections.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate relationship graphs — enumerate_RGs","text":"","code":"enumerate_RGs(MOIs, igraph = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate relationship graphs — enumerate_RGs","text":"MOIs numeric vector specifying, infection, number distinct parasite genotypes, .k.. multiplicity infection (MOI). igraph Logical whether return igraph objects.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate relationship graphs — enumerate_RGs","text":"list relationship graphs. igraph FALSE, element list four attributes: clone list groups genotypes make clonal cells. clone.vec numeric vector indicating clonal membership genotype. sib list groups clonal cells make sibling cells. sib.vec numeric vector indicating sibling membership clonal cell. Otherwise, element igraph object (see RG_to_igraph) along four attributes. Note weight matrix contains information equivalent four attributes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate relationship graphs — enumerate_RGs","text":"Relationship graphs enumerated generating nested set partitions meet certain constraints; see vignette(\"enumerate\") detailed description. summary, since clone edges induce cluster graph, information encoded clonal relationships equivalent partition genotypes. Note genotypes infection belong clonal partition cell. Subsequent information encoded sibling relationships equivalent partitioning clonal partition. constraints enumerating sibling partitions. data structure returned encodes graph nested set partition. partition represented form list vectors (clone sib) membership vector (clone.vec sib.vec), entry identifies partition cell corresponding index belongs .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate relationship graphs — enumerate_RGs","text":"","code":"graphs <- enumerate_RGs(c(2, 1, 2), igraph=TRUE) # 250 graphs #> Number of valid relationship graphs (RGs) is 250 #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> |"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_alleles.html","id":null,"dir":"Reference","previous_headings":"","what":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","title":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","text":"Note function tested input alleles mixed NA.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_alleles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","text":"","code":"enumerate_alleles(y.inf, gs.inf, use.sym = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_alleles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","text":"y.inf List alleles observed across markers genotypes within one infection. Alleles must repeated marker. gs.inf Vector genotype names genotypes within one infection. use.sym Boolean permutation symmetry exploited computational shortcut. Due permutation symmetry intra-infection genotypes, can fix single assignment one markers whose number alleles observed equal MOI (consider anchor) permute rest, discarding combinations -represent observed marker diversity. default behaviour use symmetry less assignments considered.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_alleles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","text":"List dataframes, one marker. columns correspond genotypes, rows correspond allele assignments marker.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_alleles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find all allele assignments for genotypes within the same infection — enumerate_alleles","text":"","code":"# 3 markers y.inf <- list(m1 = c(\"A\", \"B\"), m2 = c(\"B\", \"C\", \"D\"), m3 = c(\"C\")) enumerate_alleles(y.inf, c(\"g1\", \"g2\", \"g3\")) #> $m1 #>   g1 g2 g3 #> 1  B  A  A #> 2  A  B  A #> 3  B  B  A #> 4  A  A  B #> 5  B  A  B #> 6  A  B  B #>  #> $m2 #>   g1 g2 g3 #> 1  B  C  D #>  #> $m3 #>   g1 g2 g3 #> 1  C  C  C #>  # 6 assignments for m1 (BAA, ABA, BBA, AAB, BAB, ABB) # 1 assignment for m2 (accounting for permutation symmetry) # 1 assignment for m3 (CCC)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_halfsib_alleles.html","id":null,"dir":"Reference","previous_headings":"","what":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","title":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","text":"Given specified number alleles single marker, generate_halfsib_alleles() enumerates ways three half siblings can draw alleles respective parents firstly enumerating allelic combinations parents, secondly enumerating inheritable combinations children.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_halfsib_alleles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","text":"","code":"enumerate_halfsib_alleles(n_alleles)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_halfsib_alleles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","text":"n_alleles Positive whole number specifying per-marker number alleles, otherwise known marker cardinality.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_halfsib_alleles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","text":"character matrix. column individual. row possible allelic draw. Alleles represented first n_alleles letters latin alphabet.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_halfsib_alleles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List all allelic draws for three half siblings — enumerate_halfsib_alleles","text":"","code":"enumerate_halfsib_alleles(3) #>        Half sibling 1 Half sibling 2 Half sibling 3 #>   [1,] \"A\"            \"A\"            \"A\"            #>   [2,] \"B\"            \"B\"            \"A\"            #>   [3,] \"C\"            \"C\"            \"A\"            #>   [4,] \"A\"            \"A\"            \"B\"            #>   [5,] \"B\"            \"B\"            \"B\"            #>   [6,] \"C\"            \"C\"            \"B\"            #>   [7,] \"A\"            \"A\"            \"C\"            #>   [8,] \"B\"            \"B\"            \"C\"            #>   [9,] \"C\"            \"C\"            \"C\"            #>  [10,] \"A\"            \"A\"            \"A\"            #>  [11,] \"B\"            \"B\"            \"A\"            #>  [12,] \"C\"            \"C\"            \"A\"            #>  [13,] \"A\"            \"A\"            \"B\"            #>  [14,] \"B\"            \"B\"            \"B\"            #>  [15,] \"C\"            \"C\"            \"B\"            #>  [16,] \"A\"            \"A\"            \"C\"            #>  [17,] \"B\"            \"B\"            \"C\"            #>  [18,] \"C\"            \"C\"            \"C\"            #>  [19,] \"A\"            \"A\"            \"A\"            #>  [20,] \"B\"            \"B\"            \"A\"            #>  [21,] \"C\"            \"C\"            \"A\"            #>  [22,] \"A\"            \"A\"            \"B\"            #>  [23,] \"B\"            \"B\"            \"B\"            #>  [24,] \"C\"            \"C\"            \"B\"            #>  [25,] \"A\"            \"A\"            \"C\"            #>  [26,] \"B\"            \"B\"            \"C\"            #>  [27,] \"C\"            \"C\"            \"C\"            #>  [28,] \"A\"            \"A\"            \"A\"            #>  [29,] \"A\"            \"B\"            \"A\"            #>  [30,] \"A\"            \"C\"            \"A\"            #>  [31,] \"B\"            \"A\"            \"B\"            #>  [32,] \"B\"            \"B\"            \"B\"            #>  [33,] \"B\"            \"C\"            \"B\"            #>  [34,] \"C\"            \"A\"            \"C\"            #>  [35,] \"C\"            \"B\"            \"C\"            #>  [36,] \"C\"            \"C\"            \"C\"            #>  [37,] \"A\"            \"A\"            \"A\"            #>  [38,] \"A\"            \"B\"            \"A\"            #>  [39,] \"A\"            \"C\"            \"A\"            #>  [40,] \"B\"            \"A\"            \"B\"            #>  [41,] \"B\"            \"B\"            \"B\"            #>  [42,] \"B\"            \"C\"            \"B\"            #>  [43,] \"C\"            \"A\"            \"C\"            #>  [44,] \"C\"            \"B\"            \"C\"            #>  [45,] \"C\"            \"C\"            \"C\"            #>  [46,] \"A\"            \"A\"            \"A\"            #>  [47,] \"A\"            \"B\"            \"A\"            #>  [48,] \"A\"            \"C\"            \"A\"            #>  [49,] \"B\"            \"A\"            \"B\"            #>  [50,] \"B\"            \"B\"            \"B\"            #>  [51,] \"B\"            \"C\"            \"B\"            #>  [52,] \"C\"            \"A\"            \"C\"            #>  [53,] \"C\"            \"B\"            \"C\"            #>  [54,] \"C\"            \"C\"            \"C\"            #>  [55,] \"A\"            \"A\"            \"A\"            #>  [56,] \"B\"            \"A\"            \"A\"            #>  [57,] \"C\"            \"A\"            \"A\"            #>  [58,] \"A\"            \"A\"            \"B\"            #>  [59,] \"B\"            \"A\"            \"B\"            #>  [60,] \"C\"            \"A\"            \"B\"            #>  [61,] \"A\"            \"A\"            \"C\"            #>  [62,] \"B\"            \"A\"            \"C\"            #>  [63,] \"C\"            \"A\"            \"C\"            #>  [64,] \"A\"            \"B\"            \"A\"            #>  [65,] \"B\"            \"B\"            \"A\"            #>  [66,] \"C\"            \"B\"            \"A\"            #>  [67,] \"A\"            \"B\"            \"B\"            #>  [68,] \"B\"            \"B\"            \"B\"            #>  [69,] \"C\"            \"B\"            \"B\"            #>  [70,] \"A\"            \"B\"            \"C\"            #>  [71,] \"B\"            \"B\"            \"C\"            #>  [72,] \"C\"            \"B\"            \"C\"            #>  [73,] \"A\"            \"C\"            \"A\"            #>  [74,] \"B\"            \"C\"            \"A\"            #>  [75,] \"C\"            \"C\"            \"A\"            #>  [76,] \"A\"            \"C\"            \"B\"            #>  [77,] \"B\"            \"C\"            \"B\"            #>  [78,] \"C\"            \"C\"            \"B\"            #>  [79,] \"A\"            \"C\"            \"C\"            #>  [80,] \"B\"            \"C\"            \"C\"            #>  [81,] \"C\"            \"C\"            \"C\"            #>  [82,] \"A\"            \"A\"            \"A\"            #>  [83,] \"A\"            \"A\"            \"A\"            #>  [84,] \"A\"            \"A\"            \"A\"            #>  [85,] \"B\"            \"A\"            \"B\"            #>  [86,] \"B\"            \"A\"            \"B\"            #>  [87,] \"B\"            \"A\"            \"B\"            #>  [88,] \"C\"            \"A\"            \"C\"            #>  [89,] \"C\"            \"A\"            \"C\"            #>  [90,] \"C\"            \"A\"            \"C\"            #>  [91,] \"A\"            \"B\"            \"A\"            #>  [92,] \"A\"            \"B\"            \"A\"            #>  [93,] \"A\"            \"B\"            \"A\"            #>  [94,] \"B\"            \"B\"            \"B\"            #>  [95,] \"B\"            \"B\"            \"B\"            #>  [96,] \"B\"            \"B\"            \"B\"            #>  [97,] \"C\"            \"B\"            \"C\"            #>  [98,] \"C\"            \"B\"            \"C\"            #>  [99,] \"C\"            \"B\"            \"C\"            #> [100,] \"A\"            \"C\"            \"A\"            #> [101,] \"A\"            \"C\"            \"A\"            #> [102,] \"A\"            \"C\"            \"A\"            #> [103,] \"B\"            \"C\"            \"B\"            #> [104,] \"B\"            \"C\"            \"B\"            #> [105,] \"B\"            \"C\"            \"B\"            #> [106,] \"C\"            \"C\"            \"C\"            #> [107,] \"C\"            \"C\"            \"C\"            #> [108,] \"C\"            \"C\"            \"C\"            #> [109,] \"A\"            \"A\"            \"A\"            #> [110,] \"B\"            \"B\"            \"A\"            #> [111,] \"C\"            \"C\"            \"A\"            #> [112,] \"A\"            \"A\"            \"A\"            #> [113,] \"B\"            \"B\"            \"A\"            #> [114,] \"C\"            \"C\"            \"A\"            #> [115,] \"A\"            \"A\"            \"A\"            #> [116,] \"B\"            \"B\"            \"A\"            #> [117,] \"C\"            \"C\"            \"A\"            #> [118,] \"A\"            \"A\"            \"B\"            #> [119,] \"B\"            \"B\"            \"B\"            #> [120,] \"C\"            \"C\"            \"B\"            #> [121,] \"A\"            \"A\"            \"B\"            #> [122,] \"B\"            \"B\"            \"B\"            #> [123,] \"C\"            \"C\"            \"B\"            #> [124,] \"A\"            \"A\"            \"B\"            #> [125,] \"B\"            \"B\"            \"B\"            #> [126,] \"C\"            \"C\"            \"B\"            #> [127,] \"A\"            \"A\"            \"C\"            #> [128,] \"B\"            \"B\"            \"C\"            #> [129,] \"C\"            \"C\"            \"C\"            #> [130,] \"A\"            \"A\"            \"C\"            #> [131,] \"B\"            \"B\"            \"C\"            #> [132,] \"C\"            \"C\"            \"C\"            #> [133,] \"A\"            \"A\"            \"C\"            #> [134,] \"B\"            \"B\"            \"C\"            #> [135,] \"C\"            \"C\"            \"C\"            #> [136,] \"A\"            \"A\"            \"A\"            #> [137,] \"A\"            \"B\"            \"A\"            #> [138,] \"A\"            \"C\"            \"A\"            #> [139,] \"B\"            \"A\"            \"A\"            #> [140,] \"B\"            \"B\"            \"A\"            #> [141,] \"B\"            \"C\"            \"A\"            #> [142,] \"C\"            \"A\"            \"A\"            #> [143,] \"C\"            \"B\"            \"A\"            #> [144,] \"C\"            \"C\"            \"A\"            #> [145,] \"A\"            \"A\"            \"B\"            #> [146,] \"A\"            \"B\"            \"B\"            #> [147,] \"A\"            \"C\"            \"B\"            #> [148,] \"B\"            \"A\"            \"B\"            #> [149,] \"B\"            \"B\"            \"B\"            #> [150,] \"B\"            \"C\"            \"B\"            #> [151,] \"C\"            \"A\"            \"B\"            #> [152,] \"C\"            \"B\"            \"B\"            #> [153,] \"C\"            \"C\"            \"B\"            #> [154,] \"A\"            \"A\"            \"C\"            #> [155,] \"A\"            \"B\"            \"C\"            #> [156,] \"A\"            \"C\"            \"C\"            #> [157,] \"B\"            \"A\"            \"C\"            #> [158,] \"B\"            \"B\"            \"C\"            #> [159,] \"B\"            \"C\"            \"C\"            #> [160,] \"C\"            \"A\"            \"C\"            #> [161,] \"C\"            \"B\"            \"C\"            #> [162,] \"C\"            \"C\"            \"C\"            #> [163,] \"A\"            \"A\"            \"A\"            #> [164,] \"B\"            \"A\"            \"A\"            #> [165,] \"C\"            \"A\"            \"A\"            #> [166,] \"A\"            \"A\"            \"A\"            #> [167,] \"B\"            \"A\"            \"A\"            #> [168,] \"C\"            \"A\"            \"A\"            #> [169,] \"A\"            \"A\"            \"A\"            #> [170,] \"B\"            \"A\"            \"A\"            #> [171,] \"C\"            \"A\"            \"A\"            #> [172,] \"A\"            \"B\"            \"B\"            #> [173,] \"B\"            \"B\"            \"B\"            #> [174,] \"C\"            \"B\"            \"B\"            #> [175,] \"A\"            \"B\"            \"B\"            #> [176,] \"B\"            \"B\"            \"B\"            #> [177,] \"C\"            \"B\"            \"B\"            #> [178,] \"A\"            \"B\"            \"B\"            #> [179,] \"B\"            \"B\"            \"B\"            #> [180,] \"C\"            \"B\"            \"B\"            #> [181,] \"A\"            \"C\"            \"C\"            #> [182,] \"B\"            \"C\"            \"C\"            #> [183,] \"C\"            \"C\"            \"C\"            #> [184,] \"A\"            \"C\"            \"C\"            #> [185,] \"B\"            \"C\"            \"C\"            #> [186,] \"C\"            \"C\"            \"C\"            #> [187,] \"A\"            \"C\"            \"C\"            #> [188,] \"B\"            \"C\"            \"C\"            #> [189,] \"C\"            \"C\"            \"C\"            #> [190,] \"A\"            \"A\"            \"A\"            #> [191,] \"A\"            \"A\"            \"A\"            #> [192,] \"A\"            \"A\"            \"A\"            #> [193,] \"B\"            \"A\"            \"A\"            #> [194,] \"B\"            \"A\"            \"A\"            #> [195,] \"B\"            \"A\"            \"A\"            #> [196,] \"C\"            \"A\"            \"A\"            #> [197,] \"C\"            \"A\"            \"A\"            #> [198,] \"C\"            \"A\"            \"A\"            #> [199,] \"A\"            \"B\"            \"B\"            #> [200,] \"A\"            \"B\"            \"B\"            #> [201,] \"A\"            \"B\"            \"B\"            #> [202,] \"B\"            \"B\"            \"B\"            #> [203,] \"B\"            \"B\"            \"B\"            #> [204,] \"B\"            \"B\"            \"B\"            #> [205,] \"C\"            \"B\"            \"B\"            #> [206,] \"C\"            \"B\"            \"B\"            #> [207,] \"C\"            \"B\"            \"B\"            #> [208,] \"A\"            \"C\"            \"C\"            #> [209,] \"A\"            \"C\"            \"C\"            #> [210,] \"A\"            \"C\"            \"C\"            #> [211,] \"B\"            \"C\"            \"C\"            #> [212,] \"B\"            \"C\"            \"C\"            #> [213,] \"B\"            \"C\"            \"C\"            #> [214,] \"C\"            \"C\"            \"C\"            #> [215,] \"C\"            \"C\"            \"C\"            #> [216,] \"C\"            \"C\"            \"C\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Allele frequencies computed from example Plasmodium vivax data — fs_VHX_BPD","title":"Allele frequencies computed from example Plasmodium vivax data — fs_VHX_BPD","text":"posterior mean multinomial-Dirichlet model uniform prior fit data allele prevalence initial episodes. model fit allele prevalence (observed) allele frequency (requires integrating-unknown multiplicities infection) liable underestimate frequencies common alleles overestimate rare detected alleles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allele frequencies computed from example Plasmodium vivax data — fs_VHX_BPD","text":"","code":"fs_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Allele frequencies computed from example Plasmodium vivax data — fs_VHX_BPD","text":"list nine markers; marker named vector allele frequencies sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Allele frequencies computed from example Plasmodium vivax data — fs_VHX_BPD","text":"https://github.com/jwatowatson/RecurrentVivax/blob/master/RData/GeneticModel/MS_data_PooledAnalysis.RData https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/fs_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/hash.IP.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert IBD partition to a unique string for hashing — hash.IP","title":"Convert IBD partition to a unique string for hashing — hash.IP","text":"used building hash table p(y marker m|IBD).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/hash.IP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert IBD partition to a unique string for hashing — hash.IP","text":"","code":"hash.IP(IP, gs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/hash.IP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert IBD partition to a unique string for hashing — hash.IP","text":"IP List containing vectors genotype names vector corresponding IBD cell. gs Vector containing genotype names.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/hash.IP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert IBD partition to a unique string for hashing — hash.IP","text":"String integers IBD membership vector converted ASCII characters.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/hash.IP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert IBD partition to a unique string for hashing — hash.IP","text":"","code":"gs <- paste0(\"g\", 1:3) IP1 <- list(c(\"g1\", \"g3\"), c(\"g2\")) IP2 <- list(c(\"g2\"), c(\"g3\", \"g1\")) hash1 <- hash.IP(IP1, gs) hash2 <- hash.IP(IP2, gs) hash1 == hash2 # TRUE, even though the order is different #> [1] TRUE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise locus-wise data types — locus_type_summary","title":"Summarise locus-wise data types — locus_type_summary","text":"Summarise locus-wise data types","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise locus-wise data types — locus_type_summary","text":"","code":"locus_type_summary(y)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise locus-wise data types — locus_type_summary","text":"y list lists two episodes; see compute_posterior() details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise locus-wise data types — locus_type_summary","text":"vector strings summarising data locus.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarise locus-wise data types — locus_type_summary","text":"function summarise data locus one four types: match (genotypes allele). diff. (genotypes different allele). Intra-match (intra-episode genotypes allele) Inter-match (inter-episode genotypes allele). number apparent genotypes sum per-episode MOIs. total number apparent genotypes exceeds 3, \"Intra-match\" excludes \"Inter-match\" (.e., equivalent Inter-matches ), whereas \"Inter-match exclude \"Intra-match","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/locus_type_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise locus-wise data types — locus_type_summary","text":"","code":"# example code y <- list(   list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),   list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\", \"D\")) )  locus_type_summary(y) #> Warning: Intra-match excludes Inter-match; Inter-match does not exclude Intra-match #> [1] \"Inter-match\" \"Intra-match\" \"Inter-match\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":null,"dir":"Reference","previous_headings":"","what":"Upper bounds on posterior probabilities — maxima","title":"Upper bounds on posterior probabilities — maxima","text":"Upper bounds posterior probabilities first recurrence recrudescence reinfection (rows) various MOI vectors (columns) sum eight. single recurrence (MOI vectors length two), upper bounds induced prior. one recurrence (MOI vectors length three ), upper bounds assume first recurrence data; bounds valid monoclonal episodes. Two upper bounds recurrent state reported: one summation graphs includes graphs cliques three intra-episode siblings, another summation graphs excludes graphs cliques three intra-episode siblings. Since graphs cliques three intra-episode siblings apply MOI vectors include MOIs three , two bounds differ MOI vectors include MOIs three (see example ). column names represent MOI vectors whose MOIs less equal eight.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Upper bounds on posterior probabilities — maxima","text":"","code":"maxima"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Upper bounds on posterior probabilities — maxima","text":"matrix 4 rows 247 columns: C_with Upper bound posterior probability recrudescence summation includes graphs cliques three intra-episode siblings C_wout Upper bound posterior probability recrudescence summation excludes graphs cliques three intra-episode siblings I_with Upper bound posterior probability reinfection summation includes graphs cliques three intra-episode siblings I_wout Upper bound posterior probability reinfection summation excludes graphs cliques three intra-episode siblings 11 MOI vector (1, 1) 12 MOI vector (1, 2) 11111111 MOI vector (1, 1, 1, 1, 1, 1, 1, 1)","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Upper bounds on posterior probabilities — maxima","text":"https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/maxima.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Upper bounds on posterior probabilities — maxima","text":"","code":"# Convert column names to MOI character vectors MOIvec <- strsplit(colnames(maxima), split = \"\")  # Get MOI vectors with MOIs that exceed two Exceed2 <- sapply(MOIvec, function(x) any(as.numeric(x) > 2))  # Compare reinfection upper bounds with and with summation for MOI vectors that exclude # and include MOIs greater than two all(maxima[\"I_with\", !Exceed2] == maxima[\"I_wout\", !Exceed2]) #> [1] TRUE any(maxima[\"I_with\", Exceed2] == maxima[\"I_wout\", Exceed2]) #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/msg_progress_bar-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Message progress bar — msg_progress_bar-class","title":"Message progress bar — msg_progress_bar-class","text":"simple progress bar use R packages messages preferred console output. See https://gist.github.com/MansMeg/1ec56b54e1d9d238b4fd.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/msg_progress_bar-class.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Message progress bar — msg_progress_bar-class","text":"iter Total number iterations Current iteration width Width R console width_bar Width progress bar progress number character printed (continous) progress_step Addition progress per iteration","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/msg_progress_bar-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Message progress bar — msg_progress_bar-class","text":"increment() messagebar object. initialize(iter) Initialize messagebar object","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/msg_progress_bar-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Message progress bar — msg_progress_bar-class","text":"Mans Magnusson (MansMeg @ github)","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a relationship graph (RG) — plot_RG","title":"Plot a relationship graph (RG) — plot_RG","text":"function wrapper around plot.igraph, written group parasite genotypes infection, spatially using vertex colour. Specifically, parasite genotypes within infections vertically distributed horizontal jitter layout_by_group TRUE (default), coloured . also makes sure clonal sibling edges plotted differently using different line types.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"plot_RG(   RG,   layout_by_group = TRUE,   vertex_palette = \"Set2\",   edge_lty = c(`0.5` = \"dashed\", `1` = \"solid\"),   edge_col = c(`0.5` = \"black\", `1` = \"black\"),   edge_width = 1.5,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a relationship graph (RG) — plot_RG","text":"RG relationship graph, igraph graph; see return value RG_to_igraph. layout_by_group logical argument TRUE (default) overrides default layout plot.igraph vertices represent parasite genotypes different infections distributed horizontally vertices represent genotypes within infections distributed vertically. vertex_palette character string specifying RColorBrewer palette. Overrides default palette plot.igraph. edge_lty vector edge line types corresponding different relationships, 0.5 represents sibling 1 represents clone. edge_col vector edge colours corresponding different relationships, 0.5 represents sibling 1 represents clone. edge_width Overrides default edge.width plot.igraph. ... Additional arguments pass plot.igraph, e.g. edge.curved.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"provenance","dir":"Reference","previous_headings":"","what":"Provenance","title":"Plot a relationship graph (RG) — plot_RG","text":"function adapted plot_Vivax_model https://github.com/jwatowatson/RecurrentVivax/blob/master/Genetic_Model/iGraph_functions.R.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"RGs <- enumerate_RGs(c(2, 1, 1)) #> Number of valid relationship graphs (RGs) is 48 #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> | cpar <- par() # record current par before changing par(mfrow = c(3, 4), mar = c(0.1, 0.1, 0.1, 0.1)) for (i in 12:23) {   plot_RG(RGs[[i]], edge.curved = 0.1)   box() }  par(cpar) # reset par #> Warning: graphical parameter \"cin\" cannot be set #> Warning: graphical parameter \"cra\" cannot be set #> Warning: graphical parameter \"csi\" cannot be set #> Warning: graphical parameter \"cxy\" cannot be set #> Warning: graphical parameter \"din\" cannot be set #> Warning: graphical parameter \"page\" cannot be set"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the data — plot_data","title":"Plots the data — plot_data","text":"Plots alleles (colours), observed different episodes (rows), different markers (columns), episodes grouped patient. patients per-patient episodes plotted bottom top. one allele detected per episode per marker, corresponding row-column entry subdivided different colours. legend depicts alleles markers markers appear left right main plot. Otherwise stated, legend ordered order markers stated horizontal axis main plot. colour scheme adaptive. designed visually differentiate alleles much possible: maximum range qualitative scheme, contrast hue adjacent colours, always used; adjacent colours interpolated given marker 12 alleles. names alleles printed top colours marker_annotate.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the data — plot_data","text":"","code":"plot_data(ys, fs = NULL, marker_annotate = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the data — plot_data","text":"ys nested list per-patient, per-episode, per-marker allelic data. Specifically, per-patient list per-episode list per-marker list character vectors observed alleles. fs per-marker list numeric vectors allele frequencies. NULL (default), given marker, alleles present data represented legend, allele represented equally. colour scheme adaptive (see introduction), allele different colour plot alternative data list fewer alleles observed given marker across alternative data list. fs specified, possible alleles represented legend areas proportional allele frequencies; .e., common alleles relatively large legend areas, rare alleles relatively small legend areas. Specify fs fix colour given allele across plots different data lists, thereby facilitating cross-comparison. marker_annotate Logical. true (default), names alleles printed top colours legend.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the data — plot_data","text":"","code":"# Plot example Plasmodium vivax data set plot_data(ys = ys_VHX_BPD)  plot_data(ys = ys_VHX_BPD, fs = fs_VHX_BPD)  plot_data(ys = ys_VHX_BPD, fs = fs_VHX_BPD, marker_annotate = FALSE)   # Demonstrating the adaptive nature of the colour scheme: ys <- ys_VHX_BPD[\"VHX_52\"] # A single patient plot_data(ys, fs = fs_VHX_BPD) # Colours and the legend match plots above  plot_data(ys) # Colours and the legend adapt to alleles detected in VHX_52"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a 2D simplex — plot_simplex","title":"Plots a 2D simplex — plot_simplex","text":"Plots 2D simplex, triangle unit sides centred origin, onto marginal posterior probabilities relapse, reinfection recrudescence (vector three numbers zero one summing one) can projected; see project2D() examples .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a 2D simplex — plot_simplex","text":"","code":"plot_simplex(   v_labels = NULL,   v_cutoff = 0.5,   v_colours = c(\"yellow\", \"purple\", \"red\") )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a 2D simplex — plot_simplex","text":"v_labels vector labels annotate vertices anticlockwise top. NULL (default), vertices annotated. v_cutoff arbitrary number 0.5 1 separates regions lower higher probability. Beware use cut-offs probable recrudescence classification probable reinfection classification; run vignette(\"understand-posterior\"). v_colours vector colours associated vertices anticlockwise top; see example .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a 2D simplex — plot_simplex","text":"","code":"# Plot 2D simplex plot_simplex()  xy <- project2D(v = c(\"C\" = 1, \"L\" = 0, \"I\" = 0)) points(x = xy[\"x\"], xy[\"y\"], pch = \"C\") graphics::text(x = xy[\"x\"], xy[\"y\"], labels = \"(1,0,0)\", pos = 3)  xy <- project2D(v = c(\"C\" = 0, \"L\" = 1, \"I\" = 0)) points(x = xy[\"x\"], xy[\"y\"], pch = \"L\") graphics::text(x = xy[\"x\"], xy[\"y\"], labels = \"(0,1,0)\", pos = 3)  xy <- project2D(v = c(\"C\" = 0, \"L\" = 0, \"I\" = 1)) points(x = xy[\"x\"], xy[\"y\"], pch = \"I\") graphics::text(x = xy[\"x\"], xy[\"y\"], labels = \"(0,0,1)\", pos = 3)    # ============================================================================== # Given data on an enrollment episode and a recurrence, # compute the posterior probabilities of the 3Rs and plot the deviation of the # posterior from the prior # ==============================================================================  # Some data: y <- list(list(m1 = c(\"A\", \"C\"), m2 = c(\"G\", \"T\")), # Enrollment episode           list(m1 = c(\"A\"), m2 = c(\"G\"))) # Recurrent episode  # Some allele frequencies: fs <- list(m1 = setNames(c(0.4, 0.6), c(\"A\", \"C\")),            m2 = setNames(c(0.2, 0.8), c(\"G\", \"T\")))  # A vector of prior probabilities: prior <- array(c(0.2, 0.3, 0.5), dim = c(1,3),                dimnames = list(NULL, c(\"C\", \"L\", \"I\")))  # Compute posterior probabilities post <- compute_posterior(y, fs, prior) #> Number of valid relationship graphs (RGs) is 9 #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #> Computing log p(Y|RG) for 9 RGs #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #> Finding log-likelihood of each vector of recurrent states #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #>   # Projev_cutoff marginal prior probabilities onto x and y coordinates: xy_prior <- project2D(as.vector(prior))  # Projev_cutoff marginal posterior probabilities onto x and y coordinates: xy_post <- project2D(as.vector(post$marg))  # Plot simplex with probability greater than 0.8 considered relatively # certain plot_simplex(colnames(post$marg), 0.8)  # Plot the deviation of the posterior from the prior arrows(x0 = xy_prior[\"x\"], x1 = xy_post[\"x\"],        y0 = xy_prior[\"y\"], y1 = xy_post[\"y\"], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/prep_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-process data to remove repeats and NAs — prep_data","title":"Pre-process data to remove repeats and NAs — prep_data","text":"Removes repeat alleles NAs allelic vectors non-NA values. Removes repeat NAs allelic vectors NA values.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/prep_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-process data to remove repeats and NAs — prep_data","text":"","code":"prep_data(y)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/prep_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pre-process data to remove repeats and NAs — prep_data","text":"y Observed data form list lists. outer list list episodes chronological order. inner list list named markers per episode. Episode names can specified, used. Markers must named. episode must list markers. markers typed per episode, data untyped markers can encoded missing (see ). marker, one must specify allelic vector: set distinct alleles detected marker. NAs encode missing per-marker data, .e., alleles observed given marker.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/prep_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pre-process data to remove repeats and NAs — prep_data","text":"","code":"y <- list(list(m1 = c(\"A\", \"A\", NA, \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),           list(m1 = c(NA, NA), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\")))  prep_data(y) #> Warning: Ignoring allele repeats at markers with observed data (or NA repeats at markers with missing data). #> Warning: Ignoring NAs among alleles detected at markers with observed data. #> [[1]] #> [[1]]$m1 #> [1] \"A\" \"B\" #>  #> [[1]]$m2 #> [1] \"A\" #>  #> [[1]]$m3 #> [1] \"C\" #>  #>  #> [[2]] #> [[2]]$m1 #> [1] NA #>  #> [[2]]$m2 #> [1] \"B\" \"C\" #>  #> [[2]]$m3 #> [1] \"A\" \"B\" \"C\" #>  #>"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"Project three probabilities sum one (e.g., marginal probabilities 3Rs) onto coordinates 2D simplex centred origin (.e., triangle centred (0,0) unit sides).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"v numeric vector three numbers zero one sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"numeric vector two coordinates can used plot probability vector v origin-centred 2D simplex (see plot_simplex()), top, left, right vertices simplex correspond first, second third entries v respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v = c(0.75,0.20,0.05)) #>          x          y  #> -0.0750000  0.3608439"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/recombine_parent_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate parental allocations for a meiotic tetrad — recombine_parent_ids","title":"Generate parental allocations for a meiotic tetrad — recombine_parent_ids","text":"given set per chromosome marker counts, generate per marker parental ids meiotic tetrad generated sexual recombination (chromosomal crossovers followed independent assortment). assume chromosomes, pairs non-sister chromatids cross One crossover per non-sister chromatid pair Equal-length chromosomes (follows ; reality, chromosomes different lengths, number crossovers increases length) Equi-distributed markers (implicit)","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/recombine_parent_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate parental allocations for a meiotic tetrad — recombine_parent_ids","text":"","code":"recombine_parent_ids(chrs_per_marker)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/recombine_parent_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate parental allocations for a meiotic tetrad — recombine_parent_ids","text":"chrs_per_marker vector chromosome numbers marker.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/recombine_parent_ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate parental allocations for a meiotic tetrad — recombine_parent_ids","text":"","code":"n_chrs <- 14 # P. vivax has 14 chromosomes n_markers <- 100 # For 100 markers chrs_per_marker <- round(seq(0.51, n_chrs + 0.5, length.out = n_markers)) recombine_parent_ids(chrs_per_marker) #>        [,1] [,2] [,3] [,4] #>   [1,]    2    1    2    1 #>   [2,]    2    1    2    1 #>   [3,]    2    1    2    1 #>   [4,]    2    1    2    1 #>   [5,]    2    1    2    1 #>   [6,]    2    1    2    1 #>   [7,]    2    1    2    1 #>   [8,]    1    2    2    1 #>   [9,]    1    2    1    2 #>  [10,]    1    2    1    2 #>  [11,]    1    2    1    2 #>  [12,]    1    2    1    2 #>  [13,]    1    1    2    2 #>  [14,]    2    1    2    1 #>  [15,]    2    1    2    1 #>  [16,]    1    2    2    1 #>  [17,]    2    1    2    1 #>  [18,]    2    1    1    2 #>  [19,]    2    1    1    2 #>  [20,]    2    1    1    2 #>  [21,]    2    1    1    2 #>  [22,]    2    1    1    2 #>  [23,]    2    1    2    1 #>  [24,]    2    2    1    1 #>  [25,]    2    2    1    1 #>  [26,]    1    2    1    2 #>  [27,]    1    2    1    2 #>  [28,]    1    2    1    2 #>  [29,]    1    2    1    2 #>  [30,]    1    1    2    2 #>  [31,]    1    1    2    2 #>  [32,]    1    1    2    2 #>  [33,]    1    1    2    2 #>  [34,]    1    1    2    2 #>  [35,]    1    1    2    2 #>  [36,]    2    1    1    2 #>  [37,]    1    1    2    2 #>  [38,]    1    1    2    2 #>  [39,]    2    1    2    1 #>  [40,]    2    1    2    1 #>  [41,]    2    2    1    1 #>  [42,]    2    2    1    1 #>  [43,]    2    2    1    1 #>  [44,]    1    2    1    2 #>  [45,]    1    1    2    2 #>  [46,]    2    1    2    1 #>  [47,]    2    1    2    1 #>  [48,]    2    1    2    1 #>  [49,]    2    1    2    1 #>  [50,]    2    1    2    1 #>  [51,]    1    1    2    2 #>  [52,]    1    1    2    2 #>  [53,]    1    1    2    2 #>  [54,]    1    1    2    2 #>  [55,]    2    1    2    1 #>  [56,]    2    1    2    1 #>  [57,]    2    1    2    1 #>  [58,]    2    1    2    1 #>  [59,]    2    1    2    1 #>  [60,]    2    1    2    1 #>  [61,]    2    1    2    1 #>  [62,]    2    1    2    1 #>  [63,]    1    1    2    2 #>  [64,]    1    2    1    2 #>  [65,]    1    2    1    2 #>  [66,]    1    2    1    2 #>  [67,]    2    1    1    2 #>  [68,]    2    1    1    2 #>  [69,]    2    1    2    1 #>  [70,]    2    1    2    1 #>  [71,]    2    1    2    1 #>  [72,]    1    1    2    2 #>  [73,]    1    1    2    2 #>  [74,]    1    1    2    2 #>  [75,]    2    1    1    2 #>  [76,]    2    1    1    2 #>  [77,]    2    2    1    1 #>  [78,]    2    2    1    1 #>  [79,]    1    1    2    2 #>  [80,]    1    1    2    2 #>  [81,]    1    1    2    2 #>  [82,]    1    1    2    2 #>  [83,]    1    2    1    2 #>  [84,]    1    2    1    2 #>  [85,]    2    2    1    1 #>  [86,]    1    1    2    2 #>  [87,]    1    1    2    2 #>  [88,]    1    1    2    2 #>  [89,]    1    1    2    2 #>  [90,]    1    1    2    2 #>  [91,]    2    1    1    2 #>  [92,]    2    1    1    2 #>  [93,]    2    1    2    1 #>  [94,]    2    1    2    1 #>  [95,]    2    2    1    1 #>  [96,]    2    2    1    1 #>  [97,]    2    2    1    1 #>  [98,]    1    2    1    2 #>  [99,]    1    2    1    2 #> [100,]    1    2    1    2"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a transitive relationship graph — sample_RG","title":"Sample a transitive relationship graph — sample_RG","text":"Uses techniques enumerate_RGs uniformly sample relationship graph. clonal partitions generated, number sibling partitions consistent clonal partition determined. clonal partition randomly selected probability proportional corresponding number sibling partitions, sibling partition uniformly sampled. nested partition equivalent relationship graph. See enumerate_RGs details nested partition representation relationship graph.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a transitive relationship graph — sample_RG","text":"","code":"sample_RG(MOIs, igraph = T)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a transitive relationship graph — sample_RG","text":"MOIs numeric vector specifying, infection, number distinct parasite genotypes, .k.. multiplicity infection (MOI). igraph Logical whether return igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a transitive relationship graph — sample_RG","text":"relationship graph, .e. one entry list returned enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a transitive relationship graph — sample_RG","text":"","code":"set.seed(20) RG <- sample_RG(c(2, 2))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/split_two.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition a vector into at most two subvectors — split_two","title":"Partition a vector into at most two subvectors — split_two","text":"Partition vector two subvectors","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/split_two.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition a vector into at most two subvectors — split_two","text":"","code":"split_two(s)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/split_two.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition a vector into at most two subvectors — split_two","text":"s Vector split.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/split_two.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition a vector into at most two subvectors — split_two","text":"Given vector repeats, returns list consisting list contains original vector element lists list contains two disjoint vectors whose union covers vector. possible unordered pairs included.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/split_two.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition a vector into at most two subvectors — split_two","text":"","code":"gs <- paste0(\"g\", 1:3) # 4 possibilities in total # either all genotypes in one vector (1 possibility) # or 2 genotypes in one vector and the last in one vector (3 possibilties) split_two(gs) #> [[1]] #> [[1]][[1]] #> [1] \"g1\" \"g2\" \"g3\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] \"g1\" #>  #> [[2]][[2]] #> [1] \"g2\" \"g3\" #>  #>  #> [[3]] #> [[3]][[1]] #> [1] \"g1\" \"g2\" #>  #> [[3]][[2]] #> [1] \"g3\" #>  #>  #> [[4]] #> [[4]][[1]] #> [1] \"g1\" \"g3\" #>  #> [[4]][[2]] #> [1] \"g2\" #>  #>"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Plasmodium vivax data — ys_VHX_BPD","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"Previously-published microsatellite data Plasmodium vivax parasites extracted patients enrolled Best Primaquine Dose (BPD) Vivax History (VHX) trials; see https://www.nature.com/articles/s41467-019-13412-x.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"","code":"ys_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"list 217 patients; patient, list one episodes; episode, list three microsatellite markers; marker, vector observed alleles (repeat lengths). example: BPD_103 Patient identifier: patient 103 BPD trial BPD_103_1 Episode identifier: episode one patient 103 BPD trial PV.3.27 Marker identifier: Plasmodium vivax 3.27 18 Repeat length: 18","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"https://github.com/jwatowatson/RecurrentVivax/blob/master/RData/GeneticModel/MS_data_PooledAnalysis.RData https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/ys_VHX_BPD.R","code":""}]
