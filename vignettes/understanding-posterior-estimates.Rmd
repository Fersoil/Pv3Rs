---
title: "Understanding posterior estimates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding posterior estimates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%", # Line width taken up by plot
  fig.dpi = 300, # For quality 
  fig.width = 7, # Increase to zoom out
  fig.height = 4, 
  cache = TRUE
)
```

```{r setup} 
devtools::load_all(".") #library(Pv3Rs)
```

# Summary

In this vignette we document the output of `compute_posterior` when the
statistical model underpinning it is well specified and misspecified. More
specifically we document the output of `compute_posterior` when the model is
well specified but

- data are missing,
- data are uninformative, 
- data are limited to only one episode,
- data are incomparable across episodes,
- data are limited to only one marker. 

As well as when the model is well specified data on many markers:
- as a function of recurrence counts, 
- as a function of multiplicities of infection (MOIs). 
- interpretation of uncertainty
Given XXX, we highlight issues with classification based on common thresholds.

We document the output of `Pv3Rs::compute_posterior` when the model is
misspecified because of

- meiotic siblings,
- half siblings,
- parent child-like siblings,
- genotyping errors or *de novo* mutations

The results documented here are summaries from a larger study (XXX), which contains the The
likelihood results on relationship graphs described below but not shown (see
larger study for full details).

We have not yet characterised model misspecification due to inbred parasites.
However, we intuit inter-marker dependence will lead to overconfident posterior
probabilities, while population structure could lead to the misclassification of
reinfection as relapse.

```{r echo = FALSE}
# get RG vertex labels, RGs, recurrent state sequences RGs are compatible with
get_graph_dist <- function(x) { 
  gs <- paste0("g", 1:sum(x)) # genotype names (graph vertices)
  ts <- 1:length(x) # episode indices
  ts_per_gs <- rep(ts, x) # episode index of each genotype
  gs_per_ts <- split(gs, ts_per_gs) # genotypes grouped by episode
  RGs <- suppressMessages(enumerate_RGs(x)) # all relationship graphs
  CIL_gvn_RGs <- sapply(RGs, compatible_rstrs, gs_per_ts) # compatible states
  return(list(gs = gs, RGs = RGs, CIL_gvn_RGs = CIL_gvn_RGs))
}
```

# Missing data

When data are entirely missing, `compute_posterior` returns the prior. 

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y_missing = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data
suppressMessages(compute_posterior(y_missing, fs))$marg # Posterior
```

When data are missing but the user provides MOIs that are incompatible with
recrudescence, `compute_posterior` returns the prior re-weighted to the
exclusion of recrudescence.

```{r}
suppressMessages(compute_posterior(y_missing, fs, MOIs = c(1,2)))$marg 
```

# Uniformative data

When data are entirely uninformative because there is no genetic diversity,
`compute_posterior` returns the prior.

```{r}
fs = list(m1 = c("A" = 1)) # Unit allele frequencies: no genetic diversity
y = list(list(m1 = "A"), recur = list(m1 = "A")) # Data
suppressMessages(compute_posterior(y, fs))$marg # Posterior
```

# Data on only one episode 

## Monoclonal data

When only one episode has data and its MOI is one, `compute_posterior` returns
the prior (re-weighted to the exclusion of recrudescence conditional on MOIs).

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y <- list(enroll = list(m1 = NA), recur1 = list(m1 = "A")) # No enrolment data
suppressMessages(compute_posterior(y, fs))$marg # Posterior
```

When only one episode has data and its MOI is greater than one, the output of
`compute_posterior` depends on the hetero/homoallelic nature of the data. 

### Multiclonal heteroallelic data 

If the data are heteroallelic, the MOI is necessarily larger than one because
the model assumes there are no false positives. The posterior is close but not
equal to the prior because, for relationship graphs with intra-episode siblings,
the heteroallelic data limits summation over identity-by-descent partitions to
partitions with at least two cells for the episode with data. The lower bound on
the cell count increases with the number of distinct alleles observed.

```{r}
fs = list(m1 = c('A'=0.25, 'B'=0.25, 'C'=0.25, 'D'=0.25)) # Allele frequencies 

# MOI increases with number of observed alleles 
ys <- list(list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)), # Data 
           list(enroll = list(m1 = c('A','B','C')), recur = list(m1 = NA)), 
           list(enroll = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)))
do.call(rbind, lapply(ys, function(y) # Posterior 
  suppressMessages(compute_posterior(y, fs))$marg)) 

# MOI increases with external input
y <- list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data 
MOIs <- list(c(2,1), c(2,2), c(3,2)) # MOIs
do.call(rbind, lapply(MOIs, function(x) # Posterior 
  suppressMessages(compute_posterior(y, fs, MOIs = x))$marg)) 
```

### Multiclonal homoallelic data 

If the data are homoallelic, the MOI is greater than one because of external
input, and the observed allele is rare, the posterior departs from the prior
because rare intra-episode allelic repeats limit the likelihood to summation
over relationship graphs with intra-episode relatedness. We can use different
MOIs to demonstrate this: changing the MOIs changes the distribution over
relationship graphs, and thus the posterior output.

```{r}
y <- list(enroll = list(m1 = 'A'), recur = list(m1 = NA)) # Data on enroll only
MOIs <- list(c(2,1), c(2,2), c(3,2)) # Different MOIs with first MOI > 1
fs = list(m1 = c("A" = 0.01, "B" = 0.99)) # Allele frequencies
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Compute posterior 
# ------------------------------------------------------------------------------
posterior <- do.call(rbind, lapply(MOIs, function(x) # Posterior 
  suppressMessages(compute_posterior(y, fs, MOIs = x))$marg))

# ------------------------------------------------------------------------------
# Approximate posterior using graphs only
# ------------------------------------------------------------------------------
approximation <- sapply(1:length(MOIs), FUN = function(i) {
  
  gd <- get_graph_dist(MOIs[[i]])
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  
  # Identify RGs with intra-episode relatedness for the initial episode
  if(identical(MOIs[[i]], c(1,1))) { # Monoclonal case is trivial
    RGs_edges_first <- rep(TRUE, length(gd$RGs)) 
  } else { # Make adjacency matrix for the first episode
    MOI1 <- MOIs[[i]][1]; gs1 <- gd$gs[1:MOI1]
    mat <- array(1, dim = c(MOI1, MOI1), dimnames = list(gs1, gs1))
    graph <- igraph::graph_from_adjacency_matrix(mat, diag=F, mode="undirected")
    edges_first <- igraph::as_ids(igraph::E(graph)) # Edges of first episode
    RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG))) 
    RGs_edges_first <- sapply(RGs_edges, function(x) all(edges_first %in% x))
  }
  
  approx_unnormalised <- c(C = sum(RGs_edges_first*RGs_C)/sum(RGs_C),
                           L = sum(RGs_edges_first)/length(gd$RGs),
                           I = sum(RGs_edges_first*RGs_I)/sum(RGs_I))
  approx <- approx_unnormalised/sum(approx_unnormalised)
})

#-------------------------------------------------------------------------------
# Plot probabilities
#-------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posterior, 1, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], pch = 20, cex = 1, col = 1:length(MOIs))
xy <- apply(approximation, 2, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], col = 1:length(MOIs), cex = 2)
legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", "Posterior approximation"))
legend("right", col = 1:length(MOIs), pch = 20, bty = "n", inset = 0.2,
       legend = sapply(MOIs, paste, collapse = " & "), title = "MOIs")
```

The likelihood is only appreciable for relationship graphs where all parasites
in the first episode are siblings.

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 2
# ------------------------------------------------------------------------------
# Classify graphs
gd <- get_graph_dist(c(3,2))
gs <- gd$gs[1:3] # genotypes in the 1st episode
mat <- array(1, dim = c(3, 3), dimnames = list(gs, gs)) # matrix for the 1st
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_1st <- igraph::as_ids(igraph::E(graph)) # Edges of the first episode 
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))
RGs_edges_1st <- sapply(RGs_edges, function(RG_E) all(edges_1st %in% RG_E))
RGs_no_edges_1st <- sapply(RGs_edges, function(RG_E) all(!edges_1st %in% RG_E))

# Get graph log likelihoods
post <- suppressMessages(compute_posterior(y, fs, MOIs = c(3,2), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "hotpink", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graph")
points(y = llikes_sorted$x[RGs_edges_1st[llikes_sorted$ix]], col = "black",
       x = which(RGs_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[RGs_no_edges_1st[llikes_sorted$ix]], col="lightgray",
       x = which(RGs_no_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
legend("topleft", pch = 20, bty= "n", col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with only siblings within the first episode",
                  "Graphs with some siblings in the first episode",
                  "Graphs with no siblings in the first episode"))
```

Increasing the number of recurrences without adding data has little effect: the
posterior is close to the value for a single recurrence. 

```{r}
# Data with different recurrence counts but only the first recurrence has data
ys <- list("1_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA)), 
           "2_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA)), 
           "3_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA), 
                                 recur3 = list(m1 = NA)))

sapply(ys, function(y) { # Posterior for different recurrence counts
  MOIs <- c(2,2,rep(1, length(y)-2))
  suppressMessages(compute_posterior(y, fs, MOIs = MOIs))$marg["recur1",]
})
```

# Data are incomparable across episodes

When there are data on multiple episodes but no comparable data across episodes,
`compute_posterior` behaves similarly to when data are on only one episode:

- it returns the prior when episodes with data have MOIs of one, 
- its output remains close to the prior when calls are heteroallelic,
- its output departs from the prior when the call is homoallelic, the observed 
allele is rare, and the MOIs of episodes with data exceed one.

```{r}
# Allele frequencies
fs = list(m1 = c("A" = 0.01, "B" = 0.99), 
          m2 = c("A" = 0.01, "B" = 0.99)) 

# Data with an incomparable homoallelic call
y_hom <- list(enroll = list(m1 = "A", m2 = NA), 
              recur1 = list(m1 = NA, m2 = "A"))

# Data with an incomparable heteroallelic call
y_het <- list(enroll = list(m1 = c("A", "B"), m2 = NA), 
              recur1 = list(m1 = NA, m2 = c("A", "B")))

suppressMessages(compute_posterior(y_hom, fs))$marg # Prior return 
suppressMessages(compute_posterior(y_het, fs))$marg # Prior proximity
suppressMessages(compute_posterior(y_hom, fs, MOIs = c(2,2)))$marg # Departure
```

# Data on only one marker

When data on a single marker are comparable across episodes, the output
of `compute_posterior` depends on the *observation* and the frequencies of the observed alleles. For example, 

- A rare match is informative: it quashes the posterior probability of 
reinfection.
- A match with a common allele is not very informative: all states are possible 
*a posteriori*.
- A partial match with a common allele is not very informative: all states are 
possible *a posteriori*.
- A mismatch is informative because the model assumes there are no genotyping 
errors: it quashes the posterior probability of recrudescence.

```{r echo=FALSE}
# Allele frequencies
fs_rare <- list(m1 = c("A" = 0.1, "B" = 0.9))
fs_comn <- list(m1 = c("A" = 0.6, "B" = 0.4)) 


# Data 
match <- list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"))
mismatch <- list(enroll = list(m1 = c("A")), recur1 = list(m1 = "B"))
parmatch <- list(enroll = list(m1 = c("A", "B")), recur1 = list(m1 = "A"))

# Compute posterior probabilities and extract marginal probabilities
posteriors <- rbind(suppressMessages(compute_posterior(match, fs_rare))$marg, 
                    suppressMessages(compute_posterior(match, fs_comn))$marg, 
                    suppressMessages(compute_posterior(mismatch, fs_comn))$marg,
                    suppressMessages(compute_posterior(parmatch, fs_comn))$marg)

# Visualise the change in the marginal probability of the first recurrence
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posteriors, 1, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20) # Plot projections
labels <- c("common match", "rare match", "mismatch", "partial common match")
text(x = xy["x", ], y = xy["y", ], pos = 3, cex = 0.75, labels) # Annotate 
```

# Data on many markers

Given equal prior recurrent state probabilities, posterior probabilities
converge to either

- relapse with posterior probability one, 
- recrudescence with maximal posterior probability less than one, 
- reinfection with maximal posterior probability less than one, 

as the data increase with the number of markers genotyped.  

The maximal posterior probabilities of recrudescence and reinfection depend on
the number of parasite genotypes within and across infections. We demonstrate
this dependence by increasing the number of recurrences (and thus the parasite
genotype count across infections) without adding any data. Increasing
per-episode MOIs increases parasite genotype counts within infections and thus
changes maximal probabilities of recrudescence and reinfection. However,
increasing per-episode MOIs adds data inextricably.

#### Dependence on the number of subsequent recurrences

```{r echo=FALSE}
marker_count <- 100
ms <- paste0("m", 1:marker_count)
match <- as.list(sapply(ms, function(t) "A"))
mismatch <- as.list(sapply(ms, function(t) "B"))
no_data <- as.list(sapply(ms, function(t) NA))
fs <- sapply(ms, function(m) c("A" = 0.01, "B" = 0.99), simplify = FALSE)

ys_match <- list("1_recurrence" = list(enroll = match, 
                                       recur1 = match),
                 "3_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data),
                 "5_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data,
                                       recur4 = no_data,
                                       recur5 = no_data))

ys_mismatch <- list("1_recurrence" = list(enroll = match, 
                                          recur1 = mismatch),
                    "3_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data),
                    "5_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data,
                                          recur4 = no_data,
                                          recur5 = no_data))

# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])

# ------------------------------------------------------------------------------
# Posterior approximation based on graphs only
# ------------------------------------------------------------------------------
MOIs <- lapply(ys_mismatch, determine_MOIs) # MOIs, same for match and mismatch 
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  
  # Get graphs and the state sequence compatibilities
  gd <- get_graph_dist(MOIs[[i]])
  
  # Recurrent state sequences strings and characters
  sqstr <- unique(unlist(gd$CIL_gvn_RGs)) 
  sqchr <- do.call(cbind, sapply(sqstr, function(x) strsplit(x, split = "")))
  
  # Recurrent state sequences with first episode recrudescence / reinfection 
  sqstr_C_1st <- sqstr[which(sqchr[1,] == "C")] 
  sqstr_I_1st <- sqstr[which(sqchr[1,] == "I")] 
  
  # Graphs compatible with first episode recrudescence / reinfection 
  RGs_C_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_C_1st %in% x))
  RGs_I_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_I_1st %in% x))
  
  # Numbers of graphs compatible with each recurrent state sequence
  num_comp <- sapply(sqstr, function(seq) { # All graphs
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x))})
  num_comp_RGs_I_1st <- sapply(sqstr, function(seq) { # With reinfection 1st
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_I_1st)})
  num_comp_RGs_C_1st <- sapply(sqstr, function(seq) { # With recrudesc. 1st 
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_C_1st)})
  
  # Joint probabilities unnormalised and normalised
  joint_match_un <- num_comp_RGs_C_1st / num_comp
  joint_mismatch_un <- num_comp_RGs_I_1st / num_comp
  joint_match <- joint_match_un/sum(joint_match_un)
  joint_mismatch <- joint_mismatch_un/sum(joint_mismatch_un)
  
  # Marginal probabilities
  C_match <- sum(joint_match[sqstr_C_1st])
  I_mismatch <- sum(joint_mismatch[sqstr_I_1st])
  approx <- rbind(c(C = C_match, L = 1 - C_match, I = 0), 
                  c(C = 0, L = 1 - I_mismatch, I = I_mismatch))
})

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:4) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "match data", pos = 3, offset = 1) 

xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:4) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "mismatch data", pos = 3, offset = 1) 

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", "Posterior approximation"))
legend("right", col = c(1,3,5), pch = "-", pt.cex = 2, bty = "n", inset = 0.2, 
       legend = 1:4, title = "Recurrence\ncount") 
```

#### Dependence on per-episode MOIs

```{r}
MOIs <- list(c(1,1), c(3,1), c(2,2), c(3,3), c(4,2))
y_match <- ys_match[["1_recurrence"]]
y_mismatch <- ys_mismatch[["1_recurrence"]]
```

```{r echo = FALSE}
results_match <- sapply(MOIs, function(x) 
  suppressMessages(compute_posterior(y = y_match, fs, MOIs = x)$marg))
results_mismatch <- sapply(MOIs, function(x) 
  suppressMessages(compute_posterior(y = y_mismatch, fs, MOIs = x)$marg))

#------------------------------------------------------------------------------
# Posterior approximation based on graphs only
#------------------------------------------------------------------------------
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  gd <- get_graph_dist(MOIs[[i]])
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  x_match <- c(C = 1/sum(RGs_C), L = 1/length(gd$RGs), I = 0)
  x_mismatch <- c(C = 0, L = 1/length(gd$RGs), I = 1/sum(RGs_I))
  approx <- rbind(x_match/sum(x_match), x_mismatch/sum(x_mismatch))
})

#------------------------------------------------------------------------------
# Plot probabilities
#------------------------------------------------------------------------------
par(mar = c(0,0,0,0)) # Visualise the change 
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = median(xy["x", ]), y = mean(xy["y", ]), 
     labels = "match data", pos = 2, offset = 1) # Annotate

xy <- apply(results_mismatch, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = sum(range(xy["x", ]))/2, y = mean(xy["y", ]), 
     labels = "mismatch data", pos = 3, offset = 1) # Annotate

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

# Add legends
legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0,
       legend = c("Posterior probability", "Maximal probability"))
legend("right", pch = 20, pt.cex = 2, bty = "n", inset = 0.2,col=1:length(MOIs), 
       legend = gsub("c", "", as.character(MOIs)), title = "MOIs") # legend
```


The likelihood is only appreciable for relationship graphs where the parasites
in the first episode are all siblings and the inter-episode edges are clones.

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 3
# ------------------------------------------------------------------------------
# Classify graphs by state
gd <- get_graph_dist(c(3,3))
RGs_not_I <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) !("I" %in% CIL_gvn_RG))
RGs_C <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) "C" %in% CIL_gvn_RG)
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))

# Make a vector of intra-infection edges by first creating a block diag. matrix
mat <- Matrix::bdiag(lapply(c(3,3),function(x) matrix(1, ncol=x, nrow=x)))
colnames(mat) <- gd$gs; rownames(mat) <- gd$gs
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_within <- igraph::as_ids(igraph::E(graph))
RGs_edges_within <- sapply(RGs_edges, function(x) all(edges_within %in% x))

# Get graph log likelihoods
y <- ys_match[["1_recurrence"]]
post <- suppressMessages(compute_posterior(y, fs, MOIs = c(3,3), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "lightgray", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graph")
points(y = llikes_sorted$x[(RGs_not_I & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_not_I & RGs_edges_within)[llikes_sorted$ix]),
       col = "hotpink", pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[(RGs_C & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_C & RGs_edges_within)[llikes_sorted$ix]), 
       col = "black", pch = 20, cex  = 0.5)
legend("bottomright", pch = 20, bty= "n", col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with only siblings in the first episode and inter-episode clones",
                  "Graphs with only siblings in the first episode and inter-episode clones and siblings",
                  "All other graphs"))
```


## Interpreting uncertainty

The uniform prior over relationship graphs compatible with a given sequence of
recurrent states is **NOT** uninformative. When recurrent states are
equally likely *a priori*, maximal probabilities of recrudescence and of
reinfection depend on the number of episodes an individual experiences and on
the per-episode MOIs. Otherwise stated, the posterior recurrent
state space is a function of the prior on the recurrent states, the number of
episodes and their MOIs (Figure XXX).

Consequently, if we use a common threshold to classify reinfection /
recrudescence based on genetic data alone (i.e., assuming recurrence states are
equally likely *a priori*), we can discount some individuals based on their
vector of per-episode MOIs alone. For example, with a common threshold of 0.8,
we can discount all people with a single monoclonal recurrence following a
monoclonal enrolment episode, because their posterior reinfection probabilities
will never exceed 0.75, even if their data are highly informative. An
non-uniform prior on recurrent states circumvents this issue:

```{r}
y = ys_mismatch[["1_recurrence"]]
fs <- sapply(ms, FUN = function(m) c("A" = 0.5, "B" = 0.5), simplify = FALSE)

# Using the default uniform prior on recurrent states
suppressMessages(compute_posterior(y, fs))$marg

# Using an informative prior on recurrent states
prior <- as.matrix(data.frame("C" = 0.25, "L" = 0.25, "I" = 0.50))
suppressMessages(compute_posterior(y, fs, prior))$marg
```

# Meiotic siblings

## Methods 

We simulated data and generated results for an initial infection containing two
or three meiotic siblings and a recurrent

- stranger 
- clone
- regular sibling 
- meiotic sibling

## Results

When the initial infection contains two meiotic siblings `compute_posterior` is
well behaved with maximum likelihood on the true relationship graph (not shown). 
Posterior probabilities converge to

- probable reinfection when the recurrent parasite is a stranger, 
- probable recrudescence when the recurrent parasite is a clone,
- certain relapse when the recurrent parasite is a regular sibling,
- certain relapse when the recurrent parasite is a meiotic sibling. 

```{r echo = FALSE}
MOIs <- "2_1"
cases <- c("Stranger", "Clone", "Regular_sibling", "Meiotic_sibling")

for(case in cases){
  
  if( case == "Stranger") {
    exp_state <- "reinfection"    
  } else if (case == "Clone") {
    exp_state <- "recrudescence"
  } else {
    exp_state <- "relapse"
  }
  
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = sprintf("Posterior %s probability", exp_state))
  
  # Horizontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms[[MOIs]][[as.character(i)]], function(x) 
            x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

When the initial infection contains three meiotic siblings and the recurrent
parasite is either a stranger or a clone, posterior probabilities converge
correctly to probable reinfection and probable recrudescence, respectively. 

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Stranger", "Clone")

for(case in cases){

  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = "Posterior expected state probability")
  
  # Horioutputontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms[[MOIs]][[as.character(i)]], function(x) 
            x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

However, relationship graphs (not shown) are wrong for two reasons:

- all the relationship graphs have two, not three, parasites in the initial 
infection because there are at most two alleles per marker
- the maximum likelihood relationship graphs have stranger parasites in the
initial episode because prevalence data from three or four meiotic siblings are
identical to bulk data from parents who are strangers.

We can force the graphs to have the correct parasite count by specifying
external MOIs. Doing so recovers maximum likelihood on true relationship graphs.
However, the correct MOIs are unknowable in practice: a collection of siblings
from the same two parents can only ever have two alleles at a given marker
[could var genes be helpful?].

When the initial infection contains three meiotic siblings and the recurrent
parasite is a regular or meiotic sibling, posterior probabilities converge to
probable recrudescence with maximum likelihood on graphs with a clonal edge to
the sibling relapse, and either two stranger parasites in the initial episode
when no external MOIs are specified, or three sibling parasites in the initial
episode when the correct MOIs (unknowable in practice) are provided externally.

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Regular_sibling", "Meiotic_sibling")

for(case in cases){
  
  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Colour repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = "Posterior recrudescence probability")
  
  # Horioutputontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms[[MOIs]][[as.character(i)]], function(x) 
            x[,"C"]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

# Half siblings

## Methods 
We simulated data for three half siblings: two in an initial episode, the third
in a recurrence:

- child of parents 1 and 2 in the initial episode
- child of parents 1 and 3 in the initial episode
- child of parents 2 and 3 in the recurrence

We explored two scenarios: one where all parental parasites draw from the same
allele distribution. Another with admixture where parent 1 draws alleles
disproportionally to parents 2 and 3.  The admixture scenario is likely
infrequent. We explore it because it is a worse case scenario: it is contrived
to maximally hamper relapse classification.

## Results

In general, when parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped.

```{r echo = FALSE, fig.height = 4}
rm(list = "output")
output <- output_HalfSib.PCLikeSib[["Half"]]
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Colours for repeats

# Compute effective cardinality cumulatively
cum_card_eff <- sapply(output$fs_store, function(fs) {
  cumsum(sapply(fs, function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)

# Plot the posterior relapse probability trajectories
plot(NULL, bty = "n", las = 1, xaxt = "n", xlim = c(1,max(output$n_markers)), 
     xlab = "Marker count (effective cardinality)", 
     ylim = c(0,1), ylab = "Posterior relapse probability")

# Where does this 2/11 come from - correct Results_HalfSib.R accordingly
abline(h = 2/11, lty = "dashed")
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 3)
legend("center", lwd = 2, col = cols, legend = 1:output$n_repeats, bty = "n", 
       cex = 0.5, title = "Repeat")

# Add horioutputontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  lines(x = 1:max(output$n_markers),
        y = sapply(output$ps_store_all_ms[[as.character(i)]], function(x) x[,"L"]),
        col = cols[i], lwd = 2)
}
```
When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
erratically with the number of markers genotyped.

```{r echo = FALSE}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)",
     ylab = "Posterior reinfection probability")

legend("right", col = cols, lwd = 2, inset = 0.1, legend = (1:output$n_repeats)-1, 
       bty = "n", cex = 0.5, title = "Repeats")

# Add horsioutputontal axis
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", round(cum_card_eff[,"0.5"][axis_at])))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}
```
The system behaves erratically because ??? 

<!-- (The proportion of intra versus inter matches does not explain the erratic
nature of repeats 1 and 3 MyDevFiles/RelationshipStudy/Results_HalfSib.R) -->

In both scenarios, the likelihood of the true graph with siblings within and
across episodes is quashed as soon as distinct alleles from all three parents
are observed at a given marker. In general, 

- when all parasites draw from the same allele distribution, the maximum
likelihood graphs are the two with one inter-episode sibling edge.
- when intra-episode parasites systematically share rare alleles,
the maximum likelihood graph is the one with one intra-episode sibling edge.

# Parent-child like siblings

## Methods 
We simulated data for three parent-child like siblings: 

- child of selfed parent 1 in the initial episode
- child of parents 1 and 2 in the initial episode
- child of selfed parent 2 in the recurrence

Aside: the alternative with both children of selfed parents in the initial
episode is equivalent to the meiotic case above with three mieotic siblings in
the initial episode because prevalence data from three meiotic siblings is
equivalent to prevalence data from two stranger parents and leads to probable
recrudescence rather than certain relapse with the number of markers genotyped.

As for half-siblings, we explored two scenarios: one where all parental
parasites draw from the same allele distribution. Another with admixture where
parent 1 draws alleles disproportionally to parents 2 and 3. The admixture
scenario is likely infrequent. We explore it because it is a worse case
scenario: it is contrived to maximally hamper relapse classification.

## Results

When parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped.

```{r echo = FALSE}
output <- output_HalfSib.PCLikeSib[["PCLike"]]

# Colours for repeats
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") 

# Cumulative eff. cardinality 
cum_card_eff <- sapply(output$fs_store, function(fs) { 
  cumsum(sapply(fs, function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff) 

# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior relapse probability")
abline(h = 2/11, lty = "dashed") # What is this 
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 3)
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)

# Add horioutputontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats) {
  lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
        y = sapply(output$ps_store_all_ms[[as.character(i)]], function(x) x[,"L"]))
}
```

When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
very erratically with the number of markers genotyped.

```{r}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1, 
     xaxt = "n",  xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior reinfection probability")

# Add horioutputontal axis 
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}

# Add legend
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)
```
In general, when all parasites draw from the same allele distribution, the maximum
likelihood graph is the true graph with with siblings within and
across episodes. Meanwhile, when intra-episode parasites systematically share rare alleles,
the maximum likelihood graph is the one with one intra-episode sibling edge.



# Assymetry 

The marginal probabilities of relapse / reinfection of different recurrences
with the same data differ slightly because of the asymmetry in relationship
graphs: a reinfection at the end of a sequence requires all edges reaching
backward from the terminal episode to be stranger edges; at the start of a
sequence, there are no backward reaching edges to constrain.

```{r}
suppressMessages(compute_posterior(y = list(enroll = list(m1 = "A"), 
                                            recur1 = list(m1 = "A"), 
                                            recur2 = list(m1 = "A"), 
                                            recur3 = list(m1 = "A")), 
                                   fs = list(m1 = c("A" = 0.1,"B" = 0.9))))$marg




```

Due to asymmetry, the position of a "no-data" episode in a sequence of episodes
has a bearing on posterior estimates.

Below, for example, the first recurrence in the sequence OON (downward purple 1
triangle) has a higher probability of reinfection than the second recurrence in
the sequence ONO (downward orange 2 triangle) when the observations are
mismatched.

Meanwhile, for the the first recurrence in the sequence OON (upward purple 1
triangle) has a higher probability of recrudescence than the second recurrence
in the sequence ONO (upward orange 2 triangle) when the observations are
matched.

```{r}
marker_count <- 100
ms <- paste0("m", 1:marker_count)
match <- as.list(sapply(ms, function(t) "A"))
mismatch <- as.list(sapply(ms, function(t) "B"))
no_data <- as.list(sapply(ms, function(t) NA))
fs <- sapply(ms, function(m) c("A" = 0.01, "B" = 0.99), simplify = FALSE)

ys_match <- list("NOO" = list(enroll = no_data, 
                              recur1 = match,
                              recur2 = match),
                 "ONO" = list(enroll = match, 
                              recur1 = no_data,
                              recur2 = match),
                 "OON" = list(enroll = match, 
                              recur1 = match,
                              recur2 = no_data))

ys_mismatch <- list("NOO" = list(enroll = no_data, 
                                 recur1 = match,
                                 recur2 = mismatch),
                    "ONO" = list(enroll = match, 
                                 recur1 = no_data,
                                 recur2 = mismatch), 
                    "OON" = list(enroll = match, 
                                 recur1 = mismatch,
                                 recur2 = no_data))
# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])
results_match_recur2 <- sapply(results_match, function(x) x["recur2",])
results_mismatch_recur2 <- sapply(results_mismatch, function(x) x["recur2",])

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
cols <- RColorBrewer::brewer.pal(3, "Dark2")
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

n_points <- length(ys_match)
xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_match_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) 

n_points <- length(ys_mismatch)
xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_mismatch_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) # Plot 

legend("topleft", pch = c("1", "2"), bty = "n", inset = 0.1,
       legend = c(": 1st recurrence", ": 2nd recurrence"))
legend("left", pch = c(24, 25), bty = "n", inset = 0.1, pt.bg = "black", 
       legend = c("Match", "Mismatch"), title = "Observation type")
legend("right", col = cols, pch = 20, bty = "n", legend = names(ys_mismatch), 
       title = "Position of no observation (N) \namong observations (Os)") 
```

Unsurprisingly, the posterior of the first recurrence in the sequence NOO is
close to the prior, likewise for the second recurrence in the sequence of OON.
More surprisingly, the posterior of the first recurrence of the sequence ONO is
not close to the prior.

For match data, this is because strong evidence for a clonal edge between
episodes one and three is incompatible with all three recurrence sequences
ending with reinfection plus reinfection followed by recrudescence. Meanwhile,
strong evidence for a clonal edge between episodes two and three is 
incompatible with all the three recurrence sequences ending with reinfection; and
strong evidence for a clonal edge between episodes one and two is 
incompatible with all three recurrence sequences starting with reinfection. 

```{r}
epsilon <- .Machine$double.eps # Very small probability

names(which(suppressMessages(compute_posterior(y = ys_match[["ONO"]], 
                                               fs))$joint > epsilon))

names(which(suppressMessages(compute_posterior(y = ys_match[["NOO"]], 
                                               fs))$joint > epsilon))

names(which(suppressMessages(compute_posterior(y = ys_match[["OON"]], 
                                               fs))$joint > epsilon))
```


For mismatch data, strong evidence for a stranger edge between episodes one and
three is only incompatible with a double recrudescence. Meanwhile, strong
evidence for a stranger edge between episodes two and three is incompatible with
all three recurrence sequences ending with recrudescence; and strong evidence
for a clonal edge between episodes one and two is incompatible with all three
recurrence sequences starting with recrudescence.

```{r}
epsilon <- .Machine$double.eps # Very small probability

names(which(suppressMessages(compute_posterior(y = ys_mismatch[["ONO"]], 
                                               fs))$joint < epsilon))

names(which(suppressMessages(compute_posterior(y = ys_mismatch[["NOO"]], 
                                               fs))$joint < epsilon))

names(which(suppressMessages(compute_posterior(y = ys_mismatch[["OON"]], 
                                               fs))$joint < epsilon))
```




