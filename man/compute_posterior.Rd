% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_posterior.R
\name{compute_posterior}
\alias{compute_posterior}
\title{Compute the posterior distribution of recurrence states}
\usage{
compute_posterior(y, fs, prior = NULL, return.RG = FALSE)
}
\arguments{
\item{y}{Observed data in the form of a list of lists. The number of entries
is the number of episodes in chronological order. Episode names can be
specified, but they are not used. Each episode is in turn a list of
observed alleles for each marker, which must be named, or \code{NA} if not
observed. For a given marker, alleles are modeled as categorical random
variables. As such, allele names are arbitrary, but must correspond with
frequency names (see examples below). The same names can be used for
alleles belonging to different markers. As such, frequencies must be
specified per named allele per named marker.}

\item{fs}{List of allele frequencies as vectors. Names of the list must match
with the marker names in \code{y}. Within lists (i.e., for each marker),
frequencies must be specified per allele name.}

\item{prior}{Matrix of prior probabilities of the recurrence states for each
recurrent episode. Each row corresponds to an episode in chronological
order. The column names must be C, L, and I for recrudescence, relapse and
reinfection respectively. Row names can be specified by they are not used.
If prior is not provided, a uniform prior will be used.}

\item{return.RG}{Boolean for whether to return the relationship graphs,
defaults to \code{FALSE}.}
}
\value{
List containing:
\describe{
\item{marg}{Matrix of marginal posterior probabilities of the possible
recurrence states for each recurrent episode, one row per reinfection.}
\item{joint}{Vector of joint posterior probabilities of each possible string
of recurrence states.}
\item{RGs}{List of relationship graphs with their log-likelihoods stored.
Only returned if \code{return.RG} is \code{TRUE}. See
\code{\link{enumerate_RGs_alt}}.}
}
}
\description{
Entry point to Bayesian inference for \emph{P. vivax} recurrence states based
on genetic data. Specifically, this function finds the posterior
probabilities of relapse, reinfection and recrudescence from genetic data.
}
\details{
We enumerate all possible relationship graphs between genotypes, where each
pair of genotypes may be clones, siblings, or strangers, each with a
different level of expected genetic relatedness. The likelihood of a
sequence of recurrence states can be determined from the likelihood of all
relationship graphs compatible with said sequence. More details on the
enumeration and likelihood calculation of relationship graphs
can be found in \code{\link{enumerate_RGs_alt}} and
\code{\link{RG_inference}} respectively.

Model assumptions:
\itemize{
\item{No genotyping errors or missing alleles}
\item{Parasites are outbred}
\item{Relationship graphs are equally likely given recurrence states}
}
}
\examples{

# ==============================================================================
# Example where alleles are named using letters
# ==============================================================================

# Data on an enrollment episode and a recurrence:
y <- list(episode0 = list(marker1 = c("A", "C"), marker2 = c("G", "T")),
          episode1 = list(marker1 = "A", marker2 = "G"))

# Allele frequencies:
fs <- list(
  marker1 = setNames(c(0.4, 0.6), c("A", "C")),
  marker2 = setNames(c(0.2, 0.8), c("G", "T"))
)

# Compute posterior probabilities using default uniform prior, note that
# since there is only one recurrence, the marginal probabilities are the same
# as the joint probabilities:
post <- compute_posterior(y, fs); post



# ==============================================================================
# Example where alleles are given numeric names: 1, 2, 3, 4, 5
# ==============================================================================

# Allele frequencies with numeric names
fs <- list(m1=c('1'=0.78, '2'=0.14, '3'=0.07, '4'=0.005, '5' = 0.005),
           m2=c('1'=0.27, '2'=0.35, '3'=0.38),
           m3=c('1'=0.55, '2'=0.45))

# Data:
y <- list(enroll = list(m1=c('3','2'), m2=c('1','3'), m3=c('1','2')),
          recur1 = list(m1=c('1','4'), m2=c('1','2'), m3=c('1','2')),
          recur2 = list(m1=c('1','5'), m2=c('2','3'), m3=c('1')))

post <- compute_posterior(y, fs); post



#===============================================================================
# compute_posterior() returns the prior when there are either no data whatsoever
# or no recurrent data
#===============================================================================

# Allele frequencies:
fs <- list(m1 = setNames(c(0.25, 0.75), c("A", "Other")))

# Data on an enrollment episode and two recurrences:
y_no_data_whatsoever <- list(list(m1 = NA), list(m1 = NA), list(m1 = NA))
y_no_recurrent_data <- list(list(m1 = "A"), list(m1 = NA), list(m1 = NA))

# Prior on two recurrences:
prior <- array(c(0.4,0.4,0.2,0.6,0.4,0), dim = c(2,3), dimnames = list(NULL, c("C", "L", "I")))

# Compute posterior probabilities:
post3Rs_no_data_whatsover <- compute_posterior(y_no_data_whatsoever, fs, prior)
post3Rs_no_recurrent_data <- compute_posterior(y_no_recurrent_data, fs, prior)

# Compare prior with posterior marginal probabilities:
prior
post3Rs_no_data_whatsover$marg
post3Rs_no_recurrent_data$marg


# Episode info should be ordered chronologically; specified names do not override order:
y <- list(enroll = list(m1 = NA), recur1 = list(m1 = NA), recur2 = list(m1 = NA))
prior <- array(c(0.2,0.7,0.2,0.3,0.6,0), dim = c(2,3), dimnames = list(c("recur2", "recur1"), c("C", "L", "I")))
compute_posterior(y, fs, prior)
prior

#===============================================================================
# Example of small but undesirable effect on posterior of prior on graphs:
# the marginal probability that the first recurrence is a recrudescence
# increases as the number of recurrences increases even though only the first
# recurrence has data (also see vignette [to-do - base on
# MyDevFiles/Graph_prior_bias_examples.R])
#===============================================================================

# Allele frequencies:
fs <- list(m1 = setNames(c(0.25, 1-0.25), c("A", "Other")))

# Data for different scenarios; scenarios where the number of recurrences
# increases but only the first recurrence has data
ys <- list(y1 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A")),
           y2 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"), recur2 = list(m1 = NA)),
           y3 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"), recur2 = list(m1 = NA), recur3 = list(m1 = NA)),
           y4 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"), recur2 = list(m1 = NA), recur3 = list(m1 = NA), recur4 = list(m1 = NA)))

# Compute posterior probabilities and extract marginal probabilities:
results <- lapply(ys, function(y) compute_posterior(y, fs)$marg)

# Extract results for the first recurrence only:
first_recur <- sapply(results, function(result) result[1,])

# Plot 2D simplex
n_recur <- max(sapply(ys, length)-1)
pardefault <- par()
par(mar = c(0,0,0,0))
plot_simplex(v_labels = rownames(first_recur))

# Project probabilities onto 2D simplex coordinates
xy <- apply(first_recur, 2, project2D)

# Plot divergence from one recurrence to four:
arrows(x0 = xy["x", 1], x1 = xy["x", n_recur],
       y0 = xy["y", 1], y1 = xy["y", n_recur],
       length = 0.05, col = "red")

# Plot a point for each recurrence from one to four:
points(x = xy["x", ], y = xy["y", ], pch = ".")

# Restore plotting margins
par(mar = pardefault$mar)

}
