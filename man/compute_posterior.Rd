% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_posterior.R
\name{compute_posterior}
\alias{compute_posterior}
\title{Compute the posterior probability of \emph{P. vivax} recurrence states}
\usage{
compute_posterior(
  y,
  fs,
  prior = NULL,
  MOIs = NULL,
  return.RG = FALSE,
  return.logp = FALSE
)
}
\arguments{
\item{y}{Observed data in the form of a list of lists. The outer list is a
list of episodes in chronological order. The inner list is a list of named
markers per episode. Episode names can be specified, but they are not used.
Markers must be named. Each episode must list the same markers. If not all
markers are typed per episode, data on untyped markers can be encoded as
missing (see below). For each marker, one must specify an allelic vector: a
set of distinct alleles detected at that marker. \code{NA}s encode missing
per-marker data, i.e., when no alleles are observed for a given marker.
\code{NA} entries in allelic vectors that contain both \code{NA} and
non-\code{NA} entries are ignored. Allele names are arbitrary, but must
correspond with frequency names (see examples below). The same names can be
used for alleles belonging to different markers. As such, frequencies must
be specified per named allele per named marker.}

\item{fs}{List of allele frequencies as vectors. Names of the list must match
with the marker names in \code{y}. Within lists (i.e., for each marker),
frequencies must be specified per allele name.}

\item{prior}{Matrix of prior probabilities of the recurrence states for each
recurrent episode. Each row corresponds to an episode in chronological
order. The column names must be C, L, and I for recrudescence, relapse and
reinfection respectively. Row names can be specified by they are not used.
If prior is not provided, a uniform prior will be used.}

\item{MOIs}{Multiplicity of infection for each episode. If MOIs are not
provided, the most parsimonious MOIs will be used; see
\code{\link{determine_MOIs}}.}

\item{return.RG}{Boolean for whether to return the relationship graphs,
defaults to \code{FALSE}.}

\item{return.logp}{Boolean for whether to return the log-likelihood for each
relationship graph, defaults to \code{FALSE}. Setting this to \code{FALSE} allows
for permutation symmetries to be exploited to save computational time, see
\code{\link{enumerate_alleles}}. Setting this to \code{TRUE} will result in
longer runtimes, especially in the case of a larger multiplicity of
infection.}
}
\value{
List containing:
\describe{
\item{marg}{Matrix of marginal posterior probabilities of the possible
recurrence states for each recurrent episode, one row per reinfection.}
\item{joint}{Vector of joint posterior probabilities of each possible string
of recurrence states.}
\item{RGs}{List of relationship graphs with their log-likelihoods stored.
Only returned if \code{return.RG} is \code{TRUE}. See
\code{\link{enumerate_RGs}}.}
}
}
\description{
Compute the posterior probability of \emph{P. vivax} recurrence states based
on genetic data. Specifically, \code{compute_posterior} finds the posterior
probabilities of relapse, reinfection and recrudescence from genetic data.
Please note that the progress bar does not necessarily increment at a uniform
rate, and may sometimes appear to be stuck while the code is still running.
}
\details{
We enumerate all possible relationship graphs between genotypes, where each
pair of genotypes may be clones, siblings, or strangers, each with a
different level of expected genetic relatedness. The likelihood of a
sequence of recurrence states can be determined from the likelihood of all
relationship graphs compatible with said sequence. More details on the
enumeration and likelihood calculation of relationship graphs can be found in
\code{\link{enumerate_RGs}} and \code{\link{RG_inference}} respectively.

Model assumptions:
\itemize{
\item{No within-host mutations, genotyping errors, undetected alleles}
\item{Parasites are outbred}
\item{Relationship graphs are equally likely given recurrence states}
}

For each relationship graph (RG), the model sums over all possible
identity-by-descent partitions (IPs). Because some RGs are compatible with
more IPs than others, the RG log likelihood progress bar does not increment
uniformly.

At present, \code{Pv3Rs} only supports prevalence data (categorical data that
signal the detection of alleles), not quantitative data (proportional
abundance) data. The data input expects each per-episode, per-marker allelic
vector to be a set of distinct alleles. Allele repeats at markers with
observed data, and \code{NA} repeats at markers with missing data, are
removed in a data pre-processing step. \code{NA}s in allelic vectors that
also contain non-\code{NA} values are removed in a data pre-processing step.
}
\examples{

# ===========================================================================
# Example where alleles are named arbitrarily
# ===========================================================================
# Data on an enrollment episode and a recurrence:
y <- list(episode0 = list(marker1 = c("Tinky Winky", "Dipsy"),
                          marker2 = c("Tinky Winky", "Laa-Laa", "Po")),
          episode1 = list(marker1 = "Tinky Winky",
                          marker2 = "Laa-Laa"))

# Allele frequencies:
fs <- list(
  marker1 = setNames(c(0.4, 0.6), c("Tinky Winky", "Dipsy")),
  marker2 = setNames(c(0.1, 0.1, 0.2, 0.6), c("Tinky Winky", "Dipsy", "Laa-Laa", "Po"))
)

# Compute posterior probabilities using default uniform prior, note that
# since there is only one recurrence, the marginal probabilities are the same
# as the joint probabilities:
( posterior_probs <- compute_posterior(y, fs) )

# Plot posterior probabilities on the simplex
pardefault <- par()
par(mar = c(0,0,0,0))
vertex_names <- c(C = "Recrudescence", L = "Relapse", I = "Reinfection")
plot_simplex(v_labels = vertex_names[colnames(posterior_probs$marg)],
            classifcation_threshold = 0.5)
xy <- project2D(posterior_probs$marg[1,]) # Project onto 2D coordinates
points(x = xy["x"], y = xy["y"], pch = 20) # Plot projection on the simplex
par(mar = pardefault$mar) # Restore plotting margins


# ===========================================================================
# Example where alleles are given numeric names: 1, 2, 3, 4, 5
# ===========================================================================
# Data:
y <- list(enroll = list(m1=c('3','2'), m2=c('1','3'), m3=c('1','2')),
          recur1 = list(m1=c('1','4'), m2=c('1','2'), m3=c('1','2')),
          recur2 = list(m1=c('1','5'), m2=c('2','3'), m3=c('1')))

# Allele frequencies
fs <- list(m1=c('1'=0.78, '2'=0.14, '3'=0.07, '4'=0.005, '5' = 0.005),
           m2=c('1'=0.27, '2'=0.35, '3'=0.38),
           m3=c('1'=0.55, '2'=0.45))

compute_posterior(y, fs)


# ===========================================================================
# Example demonstrating the cosmetic-only nature of episode names: Input info
# and output results should be ordered and interpreted chronologically,
# regardless of episode names.
# ===========================================================================
# Data
y <- list(enroll = list(m1 = NA),
          recur2 = list(m1 = NA),
          recur1 = list(m1 = NA))

# Prior
prior <- matrix(c(0.2,0.2,0.6,0.7,0.1,0.2),
                byrow = TRUE, nrow = 2,
                dimnames = list(c("recur1", "recur2"),c("C", "L", "I")))

# Print prior and posterior, noting that the "recur1" prior is returned for
# the first recurrence, despite it being named "recur2"; the "recur2" prior is
# returned for the second recurrence, despite it being named "recur1".
prior; suppressMessages(compute_posterior(y, fs, prior))$marg


#============================================================================
# Example demonstrating the return of the prior when all data are missing and
# the effect of MOI. compute_posterior() returns the prior when there are no
# data. However, the prior will be re-weighted if MOIs are incompatible with
# recrudescence. (Recrudescing parasites are clones of parasites in the
# preceding blood-stage infection. The Pv3R model assumes no within-host
# mutations, genotyping errors or undetected alleles. As such, recrudescence is
# incompatible with an MOI increase on the preceding infection.)
#============================================================================
# Allele frequencies:
fs <- list(m1 = setNames(c(0.25, 0.75), c("A", "Other")))

# Data on enrollment and two recurrences:
y_missing <- list(enroll = list(m1 = NA),
                  recur1 = list(m1 = NA),
                  recur2 = list(m1 = NA))

# Returns the default prior:
compute_posterior(y_missing, fs)

# Returns the default prior re-weighted to the exclusion of 3R sequences with
# a recrudescence at the first recurrence:
compute_posterior(y_missing, fs, MOIs = c(1,2,1))



#============================================================================
# Example demonstrating the weakly informative nature of a heteroallelic
# call; see XXX for more details.
#============================================================================
fs = list(m1 = c('1' = 0.5, '2' = 0.5))
y <- list(enroll = list(m1 = c('1', '2')), recur = list(m1 = NA))

# The prior is not returned despite there being no recurrent data:
compute_posterior(y, fs)$marg



#============================================================================
# Example of the small but undesirable effect on the posterior of prior on
# graphs: the marginal probability that the first recurrence is a
# recrudescence increases as the number of recurrences increases even though
# only the first recurrence has data (also see vignette [to-do - base on
# MyDevFiles/Graph_prior_bias_examples.R])
#============================================================================
# Allele frequencies:
fs <- list(m1 = setNames(c(0.25, 1-0.25), c("A", "Other")))

# Data for different scenarios; scenarios where the number of recurrences
# increases but only the first recurrence has data
ys <- list(y1 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A")),
           y2 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"), recur2 = list(m1 = NA)),
           y3 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"),
                     recur2 = list(m1 = NA), recur3 = list(m1 = NA)),
           y4 = list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"),
                     recur2 = list(m1 = NA), recur3 = list(m1 = NA), recur4 = list(m1 = NA)))

# Compute posterior probabilities and extract marginal probabilities:
results <- lapply(ys, function(y) compute_posterior(y, fs)$marg)

# Extract results for the first recurrence only:
first_recur <- sapply(results, function(result) result[1,])

# Plot 2D simplex
n_recur <- max(sapply(ys, length)-1)
pardefault <- par()
par(mar = c(0,0,0,0))
vertex_names <- c(C = "Recrudescence", L = "Relapse", I = "Reinfection")
plot_simplex(v_labels = vertex_names[rownames(first_recur)], classifcation_threshold = 0.5)

# Project probabilities onto 2D simplex coordinates
xy <- apply(first_recur, 2, project2D)

# Plot divergence from one recurrence to four:
arrows(x0 = xy["x", 1], x1 = xy["x", n_recur],
       y0 = xy["y", 1], y1 = xy["y", n_recur],
       length = 0.05, col = "red")

# Plot a point for each recurrence from one to four:
points(x = xy["x", ], y = xy["y", ], pch = ".")

# Restore plotting margins
par(mar = pardefault$mar)

}
