---
title: "Understanding posterior estimates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding posterior estimates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
  knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%", # Line width taken up by plot
  fig.dpi = 300, # For quality 
  fig.width = 7, # Increase to zoom out
  fig.height = 4, 
  cache = TRUE
  )
```
  
```{r setup, include = FALSE} 
  devtools::load_all(".") #library(Pv3Rs)
options(warn = -1) # Suppress warnings about missing and limited data
sm <- function(...) suppressMessages(...) # Rename to shorten function call
```

# Summary of contents

In this vignette we document the output of `compute_posterior` when the
statistical model underpinning it is well specified and misspecified.
Specifically, we document the output of `compute_posterior` when the model is
well specified but

- data are missing,
- data are uninformative, 
- data are limited to only one episode,
- data are incomparable across episodes,
- data are limited to only one marker. 

When the model is well specified and there are data on many markers, we show how
the maximum probability of recrudescence / reinfection depends on 

- per-episode genotype counts (i.e., multiplicities of infections, MOIs),
- episode count, 
- the position of a recurrence in a sequence of episodes,

and thus comment on how the above dependencies impact the

- interpretation of uncertainty. 

Finally, we summarise results (see [development files
of the Pv3Rs source
package](https://github.com/aimeertaylor/Pv3Rs/tree/main/DevFiles/RelationshipStudy) for more detailed results)
on the output of `compute_posterior` when the model is misspecified because of

- meiotic siblings,
- half siblings,
- parent child-like siblings,
- genotyping errors and *de novo* mutations [To-do]. 

We have not characterised model misspecification due to inbred parasites. Allele
frequency estimates encode population-level relatedness locus-by-locus [Mehra et
al. preprint 2024](https://www.biorxiv.org/content/10.1101/2024.04.16.588675v1).
Allele frequency estimates are plugged into the statistical model underpinning
Pv3Rs. Providing they are computed from a sample drawn from the parasite
population from which trial participants also draw, there is no need to
compensate further for elevated relatedness locus-by-locus on the population
level. However, inter-locus dependence (linkage disequilibrium) is liable to
generate overconfident posterior probabilities. Population structure (e.g.,
household effects) could lead to the misclassification of reinfection as relapse
/ recrudescence. In our view, recurrence classification in the presence of
population structure is best understood using complementary population genetic
and sensitivity analyses.



```{r echo = FALSE}
# get RG vertex labels, RGs, recurrent state sequences RGs are compatible with
get_graph_dist <- function(x) { 
  gs <- paste0("g", 1:sum(x)) # genotype names (graph vertices)
  ts <- 1:length(x) # episode indices
  ts_per_gs <- rep(ts, x) # episode index of each genotype
  gs_per_ts <- split(gs, ts_per_gs) # genotypes grouped by episode
  RGs <- sm(enumerate_RGs(x)) # all relationship graphs
  CIL_gvn_RGs <- sapply(RGs, compatible_rstrs, gs_per_ts) # compatible states
  return(list(gs = gs, RGs = RGs, CIL_gvn_RGs = CIL_gvn_RGs))
}
```


# Missing data

When data are entirely missing, `compute_posterior` returns the prior. 

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data
sm(compute_posterior(y, fs))$marg # Posterior
```

When data are missing but the user provides MOIs that are incompatible with
recrudescence, `compute_posterior` returns the prior re-weighted to the
exclusion of recrudescence.

```{r}
sm(compute_posterior(y, fs, MOIs = c(1,2)))$marg 
```

# Uniformative data

When data are entirely uninformative because there is no genetic diversity,
`compute_posterior` returns the prior.

```{r}
fs = list(m1 = c("A" = 1)) # Unit allele frequency: no genetic diversity
y = list(list(m1 = "A"), recur = list(m1 = "A")) # Data: not missing
sm(compute_posterior(y, fs))$marg # Posterior
```

# Data on only one episode 

## Homoallelic data without user-specified MOIs

When only one episode has homoallelic data and the user does not specify an MOI
> 1, `compute_posterior` returns the prior.

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y <- list(enroll = list(m1 = NA), recur1 = list(m1 = "A")) # No enrolment data
sm(compute_posterior(y, fs))$marg # Posterior
```

## Heteroallelic data 

When only one episode has heteroallelic data, the MOI under the model
necessarily exceeds one because the model assumes no false positivity. The
posterior is close to the prior but not equal to it because the data are
slightly informative: for relationship graphs with intra-episode siblings,
heteroallelic data limit summation over identity-by-descent partitions to
partitions with at least two cells for the episode with data. Moreover, the
lower bound on the cell count increases with the number of distinct alleles
observed.

```{r}
# Allele frequencies 
fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25)) 

# MOI increases with number of observed alleles 
ys <- list(list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)), # Data 
           list(enroll = list(m1 = c('A','B','C')), recur = list(m1 = NA)), 
           list(enroll = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)))
do.call(rbind, lapply(ys, function(y) sm(compute_posterior(y, fs))$marg)) 


# MOI increases with external input
MOIs <- list(c(2,1), c(2,2), c(3,2)) 
y <- list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data 
do.call(rbind, lapply(MOIs, function(x)sm(compute_posterior(y,fs,MOIs=x))$marg)) 
```

## Rare homoallelic data with user-specified MOIs > 1 

If the data are homoallelic, but the user specifies MOIs greater than one, and
the observed allele is rare, the posterior departs from the prior because rare
intra-episode allelic repeats are more probable given relationship graphs with
intra-episode relatedness.

```{r}
y <- list(enroll = list(m1 = 'A'), recur = list(m1 = NA)) # Homoallelic data
MOIs <- list(c(2,1), c(3,2), c(5,1)) # Different MOIs with first MOI > 1
fs = list(m1 = c("A" = 0.01, "B" = 0.99)) # Rare observed allele
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Compute posterior 
# ------------------------------------------------------------------------------
posterior <- do.call(rbind, lapply(MOIs, function(x) # Posterior 
  sm(compute_posterior(y, fs, MOIs = x))$marg))

# ------------------------------------------------------------------------------
# Approximate posterior using graphs only
# ------------------------------------------------------------------------------
approximation <- sapply(1:length(MOIs), FUN = function(i) {
  
  gd <- get_graph_dist(MOIs[[i]])
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  
  # Identify RGs with intra-episode relatedness for the initial episode
  if(identical(MOIs[[i]], c(1,1))) { # Monoclonal case is trivial
    RGs_edges_first <- rep(TRUE, length(gd$RGs)) 
  } else { # Make adjacency matrix for the first episode
    MOI1 <- MOIs[[i]][1]; gs1 <- gd$gs[1:MOI1]
    mat <- array(1, dim = c(MOI1, MOI1), dimnames = list(gs1, gs1))
    graph <- igraph::graph_from_adjacency_matrix(mat, diag=F, mode="undirected")
    edges_first <- igraph::as_ids(igraph::E(graph)) # Edges of first episode
    RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG))) 
    RGs_edges_first <- sapply(RGs_edges, function(x) all(edges_first %in% x))
  }
  
  approx_unnormalised <- c(C = sum(RGs_edges_first*RGs_C)/sum(RGs_C),
                           L = sum(RGs_edges_first)/length(gd$RGs),
                           I = sum(RGs_edges_first*RGs_I)/sum(RGs_I))
  approx <- approx_unnormalised/sum(approx_unnormalised)
})

#-------------------------------------------------------------------------------
# Plot probabilities
#-------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posterior, 1, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], pch = 20, cex = 1, col = 1:length(MOIs))
xy <- apply(approximation, 2, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], col = 1:length(MOIs), cex = 2)
legend("left", pch = c(1, 20), pt.cex = c(2, 1), bty = "n", inset = 0, 
       legend = c(
         "Posterior approximation 
based on summation over 
prior probabilities of
graphs with only 
siblings in the 
first episode",
"Posterior probability"))
legend("right", col = 1:length(MOIs), pch = 20, bty = "n", inset = 0.2,
       legend = sapply(MOIs, paste, collapse = " & "), title = "MOIs")
```

The per-graph likelihood is only appreciable for relationship graphs where all distinct parasite genotypes in the first episode are siblings

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 2
# ------------------------------------------------------------------------------
# Classify graphs
gd <- get_graph_dist(c(3,2))
gs <- gd$gs[1:3] # genotypes in the 1st episode
mat <- array(1, dim = c(3,3), dimnames = list(gs, gs)) # matrix for the 1st
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_1st <- igraph::as_ids(igraph::E(graph)) # Edges of the first episode 
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))
RGs_edges_1st <- sapply(RGs_edges, function(RG_E) all(edges_1st %in% RG_E))
RGs_no_edges_1st <- sapply(RGs_edges, function(RG_E) all(!edges_1st %in% RG_E))

# Get graph log likelihoods
post <- sm(compute_posterior(y, fs, MOIs = c(3,2), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "hotpink", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graphs for MOIs 3 & 2")
points(y = llikes_sorted$x[RGs_edges_1st[llikes_sorted$ix]], col = "black",
       x = which(RGs_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[RGs_no_edges_1st[llikes_sorted$ix]], col="lightgray",
       x = which(RGs_no_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
legend("topleft", pch = 20, bty= "n", col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with only siblings within the first episode",
                  "Graphs with some siblings in the first episode",
                  "Graphs with no siblings in the first episode"))
```

Adding recurrences without adding data changes the posterior of the first
recurrence only slightly.

```{r}
# Data with different recurrence counts but only the first recurrence has data
ys <- list("1_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA)), 
           "2_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA)), 
           "3_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA), 
                                 recur3 = list(m1 = NA)))
```

```{r, echo = F}
# Posterior for different recurrence counts
t(sapply(ys, function(y) { 
  extra_MOIs <- rep(1, length(y)-2)
  sm(compute_posterior(y, fs, MOIs = c(c(2,2),extra_MOIs)))$marg["recur1",]
}))
```

# Data are incomparable across episodes

When there are data on multiple episodes but no comparable data across episodes,
`compute_posterior` behaves similarly to when data are limited to one episode:

- it returns the prior when data are homoallelic without user-specified MOIs > 1, 
- its output remains close to the prior when data are heteroallelic,
- its output departs from the prior when data are homoallelic and rare with user-specified MOIs > 1.

```{r}
# Allele frequencies
fs = list(m1 = c("A" = 0.01, "B" = 0.99), 
          m2 = c("A" = 0.01, "B" = 0.99)) 

# Data with an incomparable homoallelic call
y_hom <- list(enrol = list(m1 = "A", m2 = NA), 
              recur = list(m1 = NA, m2 = "A"))

# Data with an incomparable heteroallelic call
y_het <- list(enrol = list(m1 = c("A", "B"), m2 = NA), 
              recur = list(m1 = NA, m2 = c("A", "B")))


sm(compute_posterior(y_hom, fs))$marg # Prior return 
sm(compute_posterior(y_het, fs))$marg # Prior proximity
sm(compute_posterior(y_hom, fs, MOIs = c(2,2)))$marg # Prior departure
```

# Data on only one marker

When data on a single marker are comparable across episodes, the output of
`compute_posterior` depends on the observation type and the frequencies of the
observed alleles. For example,

- A rare match is informative: it quashes the posterior probability of 
reinfection.
- A partial rare match is also informative, quashing the posterior probability of 
reinfection.
- A match with a common allele is not very informative: all states are possible 
*a posteriori*.
- A partial match with a common allele is not very informative: all states are 
possible *a posteriori*.
- A mismatch is informative: it quashes the posterior probability of recrudescence.

```{r echo=FALSE}
# Allele frequencies
fs_rare <- list(m1 = c("A" = 0.01, "B" = 0.99))
fs_comn <- list(m1 = c("A" = 0.6, "B" = 0.4)) 

# Data 
match <- list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"))
mismatch <- list(enroll = list(m1 = c("A")), recur1 = list(m1 = "B"))
parmatch <- list(enroll = list(m1 = c("A", "B")), recur1 = list(m1 = "A"))

# Compute posterior probabilities and extract marginal probabilities
posteriors <- rbind(sm(compute_posterior(match, fs_rare))$marg, 
                    sm(compute_posterior(match, fs_comn))$marg, 
                    sm(compute_posterior(mismatch, fs_comn))$marg,
                    sm(compute_posterior(parmatch, fs_comn))$marg,
                    sm(compute_posterior(parmatch, fs_rare))$marg)

# Visualise the change in the marginal probability of the first recurrence
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posteriors, 1, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20) # Plot projections
labels <- c("rare match", "common match", "mismatch", 
            "partial common match", "partial rare match")
text(x = xy["x", ], y = xy["y", ], pos = 3, cex = 0.75, labels) # Annotate 
```
# Data on only two markers

When data on a second marker are added to the data on the first above, the
posterior updates depend on the observation types and the frequencies of the
observed alleles. When the second observation is consistent with the first the
strength of inference generally increases (see arrows entering regions of
posterior probability greater than 0.5). An exception being the addition of a
common match to a common partial match, which is not very informative (central
arrow). When a mismatch is added to a rare match (diamond), relapse becomes the
most probable state. This demonstrates the dependence of identifiable relapse
inference on data on multiple markers.


```{r echo=FALSE}
# Allele frequencies
fs_rare <- list(m1 = c("A" = 0.01, "B" = 0.99), m2 = c("A" = 0.01, "B" = 0.99))
fs_comn <- list(m1 = c("A" = 0.6, "B" = 0.4), m2 = c("A" = 0.6, "B" = 0.4)) 

A_A <- list(m1 = "A", m2 = "A")
B_B <- list(m1 = "B", m2 = "B")
A_B <- list(m1 = "A", m2 = "B")
AB_A <- list(m1 = c("A", "B"), m2 = "A")

# Data 
match <- list(enroll = A_A, recur1 = A_A)
mismatch <- list(enroll = A_A, recur1 = B_B)
parmatch <- list(enroll = AB_A, recur1 = A_A)
match_mismatch <- list(enroll = A_A, recur1 = A_B)

# Update extant probabilities and extract marginal probabilities
posteriors_ext <- rbind(sm(compute_posterior(match, fs_rare))$marg, 
                        sm(compute_posterior(match, fs_comn))$marg, 
                        sm(compute_posterior(mismatch, fs_comn))$marg,
                        sm(compute_posterior(parmatch, fs_comn))$marg,
                        sm(compute_posterior(parmatch, fs_rare))$marg)

posteriors_new <- sm(compute_posterior(match_mismatch, fs_rare))$marg

# Visualise the change in the marginal probability of the first recurrence
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy_ext <- apply(posteriors_ext, 1, project2D) # Project probabilities
xy_new <- apply(posteriors_new, 1, project2D) # Project probabilities
arrows(x0 = xy["x", ], y0 = xy["y", ], 
       x1 = xy_ext["x", ], y1 = xy_ext["y", ], length = 0.08, lwd = 2)
points(x = xy_new["x", ], y = xy_new["y", ], pch = 18, cex = 2) # Plot projections

# Annotate 
labels <- c("rare match + rare match", "common match + common match", 
            "mismatch + mismatch", "partial common match + common match", 
            "partial rare match + rare match", "rare match + mismatch")
xy_all <- cbind(xy_ext, xy_new)
text(x = xy_all["x", ], y = xy_all["y", ], pos = c(rep(4,5),3), cex = 0.75, labels) 
```

# Data on many markers

Given non-zero prior probabilities, as the data increase with the number of
markers genotyped, posterior probabilities for a given recurrence converge to
either

1) relapse with posterior probability one when the data suggest the episode of
interest is linked to previous episodes by regular sibling relationships

2) recrudescence with posterior probability less than one when the data suggest
the episode of interest is linked to the previous episode by clonal
relationships

3) reinfection with posterior probability less than one when the data suggest
the episode or interest is not linked to previous episodes by regular sibling or
clonal relationships

Recrudescence / reinfection probabilities necessarily converge to uncertain
values because genetic data compatible with recrudescence / reinfection are also
compatible with relapse (recrudescence and reinfection not fully identifiable
given genetic data alone). 

Because we assume *a priori* that relationship graphs compatible with a given
recurrent state sequence are uniformly distributed, and because relationship
graphs compatible with sequences of recrudescence / reinfection are a subset of
those compatible with sequences of relapse, the maximum posterior probability of
recrudescence / reinfection for a given recurrence can be computed *a priori* as
a function of the prior on the recurrent state sequences and the prior on the
relationship graphs; see XXX. 

Otherwise stated, when two of three states for a given recurrence are
non-identifiable despite ample data, the model returns a probability that can be
expressed as a function of the prior over recurrent state sequences and the
prior over relationship graphs, demonstrating clearly the impact of our prior
assumptions. 

Because the probability mass function of a uniformly distributed discrete random
variable depends on the size of the support, the prior on a uniformly
distributed graph, and thus the the maximum probability of recrudescence /
reinfection, depends on per-episode MOIs and episode counts, which vary across
trial participants. Using rare matched and mismatched data on 100 markers, we
demonstrate this dependency by increasing per-episode MOIs, which adds data
inextricably, and by increasing the number of recurrences without adding data.

```{r}
marker_count <- 100 # Number of markers
ms <- paste0("m", 1:marker_count) # Marker names 
all_As <- sapply(ms, function(t) "A", simplify = F) # As for all markers
all_Bs <- sapply(ms, function(t) "B", simplify = F) # Bs for all markers
all_ACs <- sapply(ms, function(t) c("A", "C"), simplify = F) # A&C for all 
no_data <- sapply(ms, function(t) NA, simplify = F) # NAs for all markers
```

## Increasing per-episode MOIs

```{r}
MOIs <- list(c(1,1), c(3,1), c(2,2), c(3,3), c(4,2)) 
fs <- sapply(ms, function(m) c("A" = 0.01, "B" = 0.01, "C" = 0.98), simplify = FALSE)
y_match <- list(enrol = all_As, recur = all_As)
y_mismatch <- list(enrol = all_As, recur = all_Bs)
```

```{r echo = FALSE}
# Assuming recurrent state sequences are equally likely a priori
results_match <- sapply(MOIs, function(x) 
  sm(compute_posterior(y = y_match, fs, MOIs = x)$marg))
results_mismatch <- sapply(MOIs, function(x) 
  sm(compute_posterior(y = y_mismatch, fs, MOIs = x)$marg))
```

```{r echo = FALSE}
#------------------------------------------------------------------------------
# Posterior approximation based on graphs only
#------------------------------------------------------------------------------
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  gd <- get_graph_dist(MOIs[[i]])
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  num_RGs_C <- sum(RGs_C)
  num_RGs_I <- sum(RGs_I)
  num_RGs_L <- length(gd$RGs)
  x_match <- c(C = 1/num_RGs_C, L = 1/num_RGs_L, I = 0)
  x_mismatch <- c(C = 0, L = 1/num_RGs_L, I = 1/num_RGs_I)
  approx <- rbind(x_match/sum(x_match), x_mismatch/sum(x_mismatch))
})

#------------------------------------------------------------------------------
# Plot probabilities
#------------------------------------------------------------------------------
par(mar = c(0,0,0,0)) # Visualise the change 
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = median(xy["x", ]), y = mean(xy["y", ]), 
     labels = "match data", pos = 2, offset = 1) # Annotate

xy <- apply(results_mismatch, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = sum(range(xy["x", ]))/2, y = mean(xy["y", ]), 
     labels = "mismatch data", pos = 3, offset = 1) # Annotate

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

# Add legends
legend("left", pch = c(1, 20), pt.cex = c(2, 1), bty = "n", inset = 0,
       legend = c(
         "Maximum probability 
based on prior over 
graphs compatible with 
recrudescence (match) /
reinfection (mismatch)", 
"Posterior probability"))
legend("right", pch = 20, pt.cex = 2, bty = "n", inset = 0.2,col=1:length(MOIs), 
       legend = gsub("c", "", as.character(MOIs)), title = "MOIs") # legend
```

To change per-episode MOIs, we either provide user-specified MOIs, or increase
the polyclonality of the data, s.t. the MOIs modelled under Pv3Rs increase.
Either way, we get the same maximal probabilities:

```{r}
MOI11_match_data <- list(enrol = all_As, MOIs11_match_data = all_As)
MOI21_match_data <- list(enrol = all_ACs, MOIs21_match_data = all_As)
MOI11_mismatch_data <- list(enrol = all_As, MOIs11_mismatch_data = all_Bs)
MOI21_mismatch_data <- list(enrol = all_ACs, MOIs21_mismatch_data = all_Bs)

rbind(sm(compute_posterior(MOI11_match_data, fs, MOIs = c(2,1))$marg), 
      sm(compute_posterior(MOI21_match_data, fs)$marg), 
      sm(compute_posterior(MOI11_mismatch_data, fs, MOIs = c(2,1))$marg),
      sm(compute_posterior(MOI21_mismatch_data, fs)$marg))
```

But they do change the probability of the data given different graphs. 

[update] For rare matched data, the likelihood is only appreciable for relationship
graphs where all intra-episode relationships are sibling and the inter-episode
relationships are clonal, demonstrating the impact of information in the data. 

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 3
# ------------------------------------------------------------------------------
# Classify graphs by state
gd <- get_graph_dist(c(3,3))
RGs_not_I <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) !("I" %in% CIL_gvn_RG))
RGs_C <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) "C" %in% CIL_gvn_RG)
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))

# Make a vector of intra-infection edges by first creating a block diag. matrix
mat <- Matrix::bdiag(lapply(c(3,3),function(x) matrix(1, ncol=x, nrow=x)))
colnames(mat) <- gd$gs; rownames(mat) <- gd$gs
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_within <- igraph::as_ids(igraph::E(graph))
RGs_edges_within <- sapply(RGs_edges, function(x) all(edges_within %in% x))

# Get graph log likelihoods
y <- y_match
post <- sm(compute_posterior(y, fs, MOIs = c(3,3), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "lightgray", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graphs for MOIs 3 & 3")
points(y = llikes_sorted$x[(RGs_not_I & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_not_I & RGs_edges_within)[llikes_sorted$ix]),
       col = "hotpink", pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[(RGs_C & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_C & RGs_edges_within)[llikes_sorted$ix]), 
       col = "black", pch = 20, cex  = 0.5)
legend("bottomright", pch = 20, bty= "n", cex = 0.75,
       col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with intra-episode siblings and inter-episode clones",
                  "Graphs with intra-episode siblings and inter-episode clones and siblings",
                  "All other graphs"))
```

## Adding recurrences 

Recurrences can be added without adding data, thereby
demonstrating the impact on the maximum probability of recrudescence /
reinfection of the prior on graphs in isolation, i.e., without additional
information from data.

```{r}
ys_match <- list("1_recurrence" = list(enroll = all_As, 
                                       recur1 = all_As),
                 "2_recurrence" = list(enroll = all_As, 
                                       recur1 = all_As,
                                       recur2 = no_data),
                 "3_recurrence" = list(enroll = all_As, 
                                       recur1 = all_As,
                                       recur2 = no_data,
                                       recur3 = no_data),
                 "5_recurrence" = list(enroll = all_As, 
                                       recur1 = all_As,
                                       recur2 = no_data,
                                       recur3 = no_data,
                                       recur4 = no_data,
                                       recur5 = no_data))

ys_mismatch <- list("1_recurrence" = list(enroll = all_As, 
                                          recur1 = all_Bs),
                    "2_recurrence" = list(enroll = all_As, 
                                          recur1 = all_Bs,
                                          recur2 = no_data),
                    "3_recurrence" = list(enroll = all_As, 
                                          recur1 = all_Bs,
                                          recur2 = no_data,
                                          recur3 = no_data),
                    "5_recurrence" = list(enroll = all_As, 
                                          recur1 = all_Bs,
                                          recur2 = no_data,
                                          recur3 = no_data,
                                          recur4 = no_data,
                                          recur5 = no_data))
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  sm(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  sm(compute_posterior(y, fs)$marg)})
```

```{r echo = FALSE}
# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])

# ------------------------------------------------------------------------------
# Posterior approximation based on graphs only
# ------------------------------------------------------------------------------
MOIs <- lapply(ys_mismatch, determine_MOIs) # MOIs, same for match and mismatch 
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  
  # Get graphs and the state sequence compatibilities
  gd <- get_graph_dist(MOIs[[i]])
  
  # Recurrent state sequences strings and characters
  sqstr <- unique(unlist(gd$CIL_gvn_RGs)) 
  sqchr <- do.call(cbind, sapply(sqstr, function(x) strsplit(x, split = "")))
  
  # Recurrent state sequences with first episode recrudescence / reinfection 
  sqstr_C_1st <- sqstr[which(sqchr[1,] == "C")] 
  sqstr_I_1st <- sqstr[which(sqchr[1,] == "I")] 
  
  # Graphs compatible with first episode recrudescence / reinfection 
  RGs_C_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_C_1st %in% x))
  RGs_I_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_I_1st %in% x))
  
  # Numbers of graphs compatible with each recurrent state sequence
  num_comp <- sapply(sqstr, function(seq) { # All graphs
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x))})
  num_comp_RGs_I_1st <- sapply(sqstr, function(seq) { # With reinfection 1st
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_I_1st)})
  num_comp_RGs_C_1st <- sapply(sqstr, function(seq) { # With recrudesc. 1st 
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_C_1st)})
  
  # Joint probabilities unnormalised and normalised
  joint_match_un <- num_comp_RGs_C_1st / num_comp
  joint_mismatch_un <- num_comp_RGs_I_1st / num_comp
  joint_match <- joint_match_un/sum(joint_match_un)
  joint_mismatch <- joint_mismatch_un/sum(joint_mismatch_un)
  
  # Marginal probabilities
  C_match <- sum(joint_match[sqstr_C_1st])
  I_mismatch <- sum(joint_mismatch[sqstr_I_1st])
  approx <- rbind(c(C = C_match, L = 1 - C_match, I = 0), 
                  c(C = 0, L = 1 - I_mismatch, I = I_mismatch))
})
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(ys_match)) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "match data", pos = 3, offset = 1) 

xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(ys_mismatch)) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "mismatch data", pos = 3, offset = 1) 

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

legend("left", pch = c(1, 20), pt.cex = c(2, 1), bty = "n", inset = 0, 
       legend = c(
         "Maximum probability  
based on prior over  
graphs compatible with 
recrudescence first (match) / 
reinfection first (mismatch)", "Posterior probability"))
legend("right", col = c(1:length(xys)), pch = "-", pt.cex = 2, bty = "n", inset = 0.2, 
       legend = c(1,2,3,5), title = "Recurrence\ncount") 
```

## Position in a sequence  

Because the distribution over relationship graphs is not invariant to different
episode orderings (more graphs are compatible with a reinfection at the
beginning versus the end of a sequence of three episodes, for example), the
position of a recurrence in a sequence of episodes has a bearing on posterior
estimates.

That said, this effect is negligible when all episodes have the same data on
many markers:

```{r}
y <- list(enroll = all_As, 
          recur1 = all_As, 
          recur2 = all_As, 
          recur3 = all_As)
sm(compute_posterior(y, fs))$marg
```

Instead, consider sequences of episodes with observations (Os) and episodes with
no data (Ns):

```{r}
ys_match <- list("NOO" = list(enroll = no_data, 
                              recur1 = all_As,
                              recur2 = all_As),
                 "ONO" = list(enroll = all_As, 
                              recur1 = no_data,
                              recur2 = all_As),
                 "OON" = list(enroll = all_As, 
                              recur1 = all_As,
                              recur2 = no_data))

ys_mismatch <- list("NOO" = list(enroll = no_data, 
                                 recur1 = all_As,
                                 recur2 = all_Bs),
                    "ONO" = list(enroll = all_As, 
                                 recur1 = no_data,
                                 recur2 = all_Bs), 
                    "OON" = list(enroll = all_As, 
                                 recur1 = all_Bs,
                                 recur2 = no_data))
``` 

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  sm(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  sm(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])
results_match_recur2 <- sapply(results_match, function(x) x["recur2",])
results_mismatch_recur2 <- sapply(results_mismatch, function(x) x["recur2",])

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
cols <- RColorBrewer::brewer.pal(3, "Dark2")
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

n_points <- length(ys_match)
xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_match_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) 

n_points <- length(ys_mismatch)
xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_mismatch_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) # Plot 

legend("topleft", pch = c("1", "2"), bty = "n", inset = 0.1,
       legend = c(": 1st recurrence", ": 2nd recurrence"))
legend("left", pch = c(24, 25), bty = "n", inset = 0.1, pt.bg = "black", 
       legend = c("Match", "Mismatch"), title = "Observation type")
legend("right", col = cols, pch = 20, bty = "n", legend = names(ys_mismatch), 
       title = "Position of no observation (N) \namong observations (Os)") 
```

### Highly informed recurrences  

Highly informed matched recurrence (upward purple and green triangles): The first
recurrence in the sequence <span style="color: purple;">**O**ON</span> (upward
purple 1 triangle) has a lower probability of recrudescence than second
recurrence in the sequence <span style="color: darkgreen;">NO**O**</span>
(upward green 2 triangle) despite both recurrences having the same rare
observations that match the directly preceding episode.

Highly informed mismatched recurrence (downward purple and green triangles): The first
recurrence in the sequence <span style="color: purple;">**O**ON</span> (downward
purple 1 triangle) has a higher probability of reinfection than the second
recurrence in the sequence <span style="color: darkgreen;">NO**O**</span>
(downward green 2 triangle) despite both recurrences having the same
observations that mismatch the directly preceding episode.

### Weakly and uninformed recurrences  

Unsurprisingly, the posterior of the first recurrence in the sequence <span
style="color: darkgreen;">N**O**O</span> is close to the prior (it has no
preceding data), likewise for the second recurrence in the sequence of <span
style="color: purple;">OO**N**</span> (it has no data). More surprisingly
(initially at least), the posterior of the first recurrence of the sequence
<span style="color: darkorange;">O**N**O</span> is not close to the prior,
despite having no data. On closer inspection, this is not so surprising for
reasons explained below.

For match data (upward triangles), strong evidence for a clonal edge between
episodes one and three in <span style="color: darkorange;">ONO</span> is
incompatible with all recurrence sequences ending with reinfection *and*
reinfection followed by recrudescence, informing the second strongly and the
first recurrence weakly. By comparison, strong evidence for a clonal edge
between episodes two and three in <span style="color: darkgreen;">NO**O**</span>
is incompatible with all sequences of recurrences ending with reinfection,
informing the second recurrence only; likewise, strong evidence for a clonal
edge between episodes one and two in <span style="color: purple;">OON</span> is
incompatible with all sequences of recurrences starting with reinfection,
informing the first recurrence only.

```{r}
epsilon <- .Machine$double.eps # Very small probability
names(which(sm(compute_posterior(y = ys_match[["ONO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_match[["NOO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_match[["OON"]], fs))$joint < epsilon))
```

On close inspection the upward orange 1 triangle makes intuitive sense: if you
know a first recurrence is followed by a second MOI = 1 recurrence that is a
clone of the MOI = 1 enrolment episode, it is very unlikely the second
recurrence is a clone drawn from a new mosquito as it would be if it were a
recrudescence of a reinfection. As such, the data on the enrolment episode and
the second recurrence tell us something about the first recurrence, and thus the
posterior estimate of the first recurrence deviates from the prior even though
the first recurrence has no data.

The explanation for mismatch data (downward triangles) in the sequence <span style="color:
darkorange;">ONO</span> is similar to that for match data: strong evidence for
a stranger edge between episodes one and three is incompatible with a double
recrudescence, so the posterior of the first recurrence (downward orange 1
triangle) deviates from the prior despite the first recurrence having no data.

```{r}
epsilon <- .Machine$double.eps # Very small probability
names(which(sm(compute_posterior(y = ys_mismatch[["ONO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_mismatch[["NOO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_mismatch[["OON"]], fs))$joint < epsilon))
```

# Interpreting uncertainty

Uncertain posterior estimates can be uncertain for two reasons that are not
mutually exclusive:

1) more data are needed 
2) the states are not fully identifiable

To assess data requirements, we could report relative uncertainty: how uncertain
a posterior estimate is from its maximum, which can be computed *a priori*
because we assume relationship graphs compatible with a given recurrent state
sequence are equally likely.

Trial participants have maximum probabilities of recrudescence / reinfection
that are unequal *a priori* (because of the conditional uniform assumption on
relationship graphs, the maximum probabilities of recrudescence / reinfection
depend on the number of genotypes within and across infections, and thus vary
across trial participants). This is important to bear in mind when comparing
estimates across people. For example, if we use a common threshold of 0.8 to
classify probable reinfection assuming recurrence states are equally likely *a
priori*, we can discount *a priori* all trail participants with a single
monoclonal recurrence following a monoclonal enrolment episode because their
posterior reinfection probabilities will never exceed 0.75, even if their data
are highly informative of reinfection.

```{r}
y <- list(enrol = all_As, recur = all_Bs)
fs <- sapply(ms, FUN = function(m) c("A" = 0.5, "B" = 0.5), simplify = FALSE)

# Using the default uniform prior on recurrent states
sm(compute_posterior(y, fs))$marg

# Using a non-uniform prior on recurrent states
prior <- as.matrix(data.frame("C" = 0.25, "L" = 0.25, "I" = 0.5))
sm(compute_posterior(y, fs, prior))$marg
```

For a given trial participant, maximum probabilities of recrudescence /
reinfection vary with the position of a recurrence in a sequence, especially if
one or more episodes has no data.

# Meiotic siblings

## Methods 

We simulated data and generated results for an initial infection containing two
or three meiotic siblings and a recurrent

- stranger 
- clone
- regular sibling 
- meiotic sibling

Posterior probabilities are computed assuming recurrent states are equally
likely *a priori*.

## Results

When the initial infection contains two meiotic siblings `compute_posterior` is
well behaved with maximum likelihood on the true relationship graph (not shown). 
Posterior probabilities converge to

- probable reinfection when the recurrent parasite is a stranger, 
- probable recrudescence when the recurrent parasite is a clone,
- certain relapse when the recurrent parasite is a regular sibling,
- certain relapse when the recurrent parasite is a meiotic sibling. 

```{r echo = FALSE}
MOIs <- "2_1"
cases <- c("Stranger", "Clone", "Regular_sibling", "Meiotic_sibling")

for(case in cases){
  
  if( case == "Stranger") {
    exp_state <- "reinfection"    
  } else if (case == "Clone") {
    exp_state <- "recrudescence"
  } else {
    exp_state <- "relapse"
  }
  
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = sprintf("Posterior %s probability", exp_state))
  
  if(case == "Stranger") {
    # Add expected probability based on normalised odds from on theoretical results
    abline(h = 9/11, lty = "dashed") 
    text(x = 10, y = 9/11, labels = "9/11", pos = 3)
  }
  
  if(case == "Clone") {
    # Add expected probability based on normalised odds from on theoretical results
    abline(h = 9/13, lty = "dashed") 
    text(x = 10, y = 9/13, labels = "9/13", pos = 3)
  }
  
  # Horizontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

When the initial infection contains three meiotic siblings and the recurrent
parasite is either a stranger or a clone, posterior probabilities converge
correctly to probable reinfection and probable recrudescence, respectively, but
with maximal values given by graphs over relationships between two, not three,
parasites in the initial infection.

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Stranger", "Clone")

for(case in cases){
  
  if( case == "Stranger") {
    exp_state <- "reinfection"    
  } else if (case == "Clone") {
    exp_state <- "recrudescence"
  } else {
    exp_state <- "relapse"
  }
  
  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", 
       las = 1, xaxt = "n", xlab = "", 
       ylab = sprintf("Posterior %s probability", exp_state))
  
  if(case == "Stranger") {
    # Add expected probability based on graphs over n = 3 genotypes
    abline(h = 9/11, lty = "dashed") 
    text(x = 10, y = 9/11, labels = "9/11", pos = 3)
  }
  
  if(case == "Clone") {
    # Add expected probability based on graphs over n = 3 genotypes
    abline(h = 9/13, lty = "dashed") 
    text(x = 10, y = 9/13, labels = "9/13", pos = 3)
  }
  
  # Horizontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

However, relationship graphs (not shown) are wrong for two reasons:

- all the relationship graphs have two, not three, parasites in the initial 
infection because there are at most two alleles per marker
- the highest likelihood relationship graphs have stranger parasites in the
initial episode because prevalence data from three or four meiotic siblings are
identical to bulk data from parents and the parents are strangers.

We can force the graphs to have the correct parasite count by specifying
external MOIs. Doing so recovers maximum likelihood on true relationship graphs.
However, the correct MOIs are unknowable in practice: a collection of siblings
from the same two parents can only ever have two alleles at a given marker.

When the initial infection contains three meiotic siblings and the recurrent
parasite is a regular or meiotic sibling, posterior probabilities converge to
probable recrudescence with maximum likelihood on graphs with a clonal edge to
the sibling relapse, and either two stranger parasites in the initial episode
when no external MOIs are specified, or three sibling parasites in the initial
episode when the correct MOIs (unknowable in practice) are provided externally.

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Regular_sibling", "Meiotic_sibling")

for(case in cases){
  
  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Colour repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = "Posterior recrudescence probability")
  
  # Add expected probability based on graphs over n = 3 genotypes
  abline(h = 9/13, lty = "dashed") 
  text(x = 10, y = 9/13, labels = "9/13", pos = 3)
  
  # Horizontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,"C"]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

# Half siblings

## Methods 
We simulated data for three half siblings: two in an initial episode, the third
in a recurrence:

- child of parents 1 and 2 in the initial episode
- child of parents 1 and 3 in the initial episode
- child of parents 2 and 3 in the recurrence

We explored two scenarios: one where all parental parasites draw from the same
allele distribution. Another with admixture where parent 1 draws alleles
disproportionally to parents 2 and 3.  The admixture scenario is improbable. We
explore it because it is a worse case scenario: it is contrived to maximally
hamper relapse classification.

## Results

In general, when parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped. 

For this particular case where there are three equifrequent alleles per marker,
we can show theoretically that the system behaves erratically because a small
perturbation to the ratio of observations (all alleles match across the three
half siblings, all alleles are different, intra-episode alleles match,
inter-episode alleles match) can lead to a large deviation in the odds of
relapse versus reinfection. The purple, red, and green trajectories below have
higher than the expected 0.5 intra-to-inter match ratios; moreover, the purple
trajectory's intra-to-inter match ratio consistently exceeds $0.5\times
\text{log}_2(\dfrac{2}{5})$  — a condition found theoretically to concentrate posterior
probability on reinfection under certain conditions. <!-- 2^(2m3) >> 2^(m-2m2)
-->

```{r echo = FALSE, fig.height = 4}
rm(list = "output")
output <- output_HalfSib.PCLikeSib[["Half"]]
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # For repeats

# Compute effective cardinality cumulatively in the order of markers genotyped
cum_card_eff <- sapply(output$fs_store, function(fs) {
  cumsum(sapply(fs[output$m_rorder], function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)

# Plot the posterior relapse probability trajectories
plot(NULL, bty = "n", las = 1, xaxt = "n", xlim = c(1,max(output$n_markers)), 
     xlab = "Marker count (effective cardinality)", 
     ylim = c(0,1), ylab = "Posterior relapse probability")
legend("right", lwd = 2, col = cols, legend = 1:output$n_repeats, bty = "n", 
       cex = 0.5, title = "Repeat")

# Add expected probability based on normalised odds from on theoretical results
abline(h = 2/11, lty = "dashed") 
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 1)

# Add horizontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  lines(x = 1:max(output$n_markers),
        y = sapply(output$ps_store_all_ms_uniform[[as.character(i)]], 
                   function(x) x[,"L"]),
        col = cols[i], lwd = 2)
}
```
When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
erratically with the number of markers genotyped.

```{r echo = FALSE}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)",
     ylab = "Posterior reinfection probability")

legend("right", col = cols, lwd = 2, inset = 0.1, legend = (1:output$n_repeats)-1, 
       bty = "n", cex = 0.5, title = "Repeats")

# Add expected probability based on normalised odds from on theoretical results
abline(h = 9/11, lty = "dashed") 
text(x = max(output$n_markers), y = 9/11, labels = "9/11", pos = 3)

# Add horizontal axis
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", round(cum_card_eff[,"0.5"][axis_at])))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],
              function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}
```
In both scenarios, the likelihood of the true graph with siblings within and
across episodes is quashed as soon as distinct alleles from all three parents
are observed at a given marker. In general, 

- when all parasites draw from the same allele distribution, the maximum
likelihood graphs are the two with one inter-episode sibling edge.
- when intra-episode parasites systematically share rare alleles,
the maximum likelihood graph is the one with one intra-episode sibling edge.

# Parent-child like siblings

## Methods 
We simulated data for three parent-child like siblings: 

- child of selfed parent 1 in the initial episode
- child of parents 1 and 2 in the initial episode
- child of selfed parent 2 in the recurrence

Aside: the alternative with both children of selfed parents in the initial
episode is equivalent to the meiotic case above with three mieotic siblings in
the initial episode because prevalence data from three meiotic siblings is
equivalent to prevalence data from two stranger parents and leads to probable
recrudescence rather than certain relapse with the number of markers genotyped.

As for half-siblings, we explored two scenarios: one where all parental
parasites draw from the same allele distribution. Another with admixture where
parent 1 draws alleles disproportionally to parents 2 and 3. The admixture
scenario is improbable. We explore it because it is a worse case
scenario: it is contrived to maximally hamper relapse classification.

## Results

When parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped.

```{r echo = FALSE}
output <- output_HalfSib.PCLikeSib[["PCLike"]]

# Colours for repeats
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") 

# Cumulative eff. cardinality 
cum_card_eff <- sapply(output$fs_store, function(fs) { 
  cumsum(sapply(fs, function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff) 

# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior relapse probability")
abline(h = 2/11, lty = "dashed") # What is this ??? 
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 1)
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)

# Add Horizontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats) {
  lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
        y = sapply(output$ps_store_all_ms_uniform[[as.character(i)]], 
                   function(x) x[,"L"]))
}
```

When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
erratically with the number of markers genotyped.

```{r echo = FALSE}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1, 
     xaxt = "n",  xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior reinfection probability")

# Add expected probability based on normalised odds from on theoretical results
abline(h = 9/11, lty = "dashed") 
text(x = max(output$n_markers), y = 9/11, labels = "9/11", pos = 3)

# Add horizontal axis 
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],
              function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}

# Add legend
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)
```

In general, when all parasites draw from the same allele distribution, the
maximum likelihood graph is the true graph with siblings within and across
episodes. Meanwhile, when intra-episode parasites systematically share rare
alleles, the maximum likelihood graph is the one with one intra-episode sibling
edge.






