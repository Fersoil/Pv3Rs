#' Enumerate relationship graphs (RGs)
#'
#' An RG is a complete graph over all per-person parasite haploid
#' genotypes (each as a vertex), with edges labelled clone, sibling, or stranger.
#' Valid RGs satisfy:
#' \itemize{
#'   \item{The subgraph induced by the clone edges is a cluster graph.}
#'   \item{The subgraph induced by the clone plus sibling edges is a cluster
#'   graph.}
#'   \item{Clone edges only link genotypes from different episodes.}
#' }
#'
#' RGs are generated by enumerating nested set partitions under specific
#' constraints (see [vignette("enumerate")](../doc/enumerate.pdf) for details).
#' Clone edges induce a cluster graph, equivalent to a partition of genotypes,
#' with no clones allowed within the same episode. Sibling edges refine the
#' clone partition, with no constraints (intra-episode siblings allowed). Each
#' RG is encoded as a list that encodes the nested set partition. Each partition
#' is represented in the form of a list of vectors (`clone` and `sib`) and as a
#' membership vector (`clone.vec` and `sib.vec`). By default, an RG encoded as a
#' list is converted to an `igraph` object.
#'
#' @param MOIs Numeric vector of per-episode multiplicities of infection (MOIs),
#' i.e., number of vertices per episode.
#' @param igraph Logical; returns RGs as \code{igraph} objects (default `TRUE`).
#' @param progress.bar Logical; show progress bar (default `TRUE`).
#'
#' @return A list of RGs. If `igraph = FALSE`,
#' each RG is a list of length four with:
#'   \describe{
#'     \item{clone}{List of vectors encoding genotypes per clonal cell.}
#'     \item{clone.vec}{Numeric vector with the clonal cell membership of
#'     each genotype.}
#'     \item{sib}{List of vectors encoding clonal cells per sibling cell.}
#'     \item{sib.vec}{Numeric vector with the sibling cell membership of
#'     each clonal cell.}
#'   }
#'   If `igraph = TRUE` (default), each RG is encoded as an \code{igraph} object
#'   (see \code{\link{RG_to_igraph}}) encoding equivalent information via edge weights.
#'
#' @examples
#' graphs <- enumerate_RGs(c(2, 1, 2)) # nine graphs
#'
#' @export
enumerate_RGs <- function(MOIs, igraph = TRUE, progress.bar = TRUE) {
  # Check MOIs are positive whole numbers
  if (!all(is_wholenumber(MOIs)) | any(MOIs < 1)) stop("MOIs should be positive integers")

  if(sum(MOIs) > 10) message("Total MOI > 10 may lead to high memory use")

  infection_count <- length(MOIs) # Number of time points
  gs_count <- sum(MOIs) # Number of genotypes

  # compute set partitions
  part.list <- list()
  for (i in 1:gs_count) {
    part.list[[i]] <- partitions::setparts(i)
  }

  gs <- paste0("g", 1:gs_count) # Genotype names
  ts_per_gs <- rep(1:infection_count, MOIs)

  # get clonal partitions, accounting for no intra-infection clones
  CP_list <- enumerate_CPs(MOIs)

  RG_i <- 0
  RGs <- list() # list of relationship graphs

  # Count number of valid graphs and create progress bar
  n.RG <- sum(sapply(CP_list, function(x) ncol(part.list[[max(x)]])))
  if (progress.bar) pbar <- msg_progress_bar(n.RG)
  message(paste("Number of valid relationship graphs (RGs) is", n.RG))

  for (CP in CP_list) { # for each clonal partition (membership vector)
    n.clones <- max(CP) # number of clonal cells
    clone.names <- paste0("c", 1:n.clones)
    # list of vectors of genotype names by clonal cell
    clones <- stats::setNames(split(gs, CP), clone.names)

    # given clonal relationships, generate all compatible sibling relationships
    # sibling partitions are all set partitions of the clonal cells
    sib.parts <- part.list[[n.clones]]
    n.parts <- ncol(sib.parts) # number of possible partitions
    for (j in 1:n.parts) { # for each sibling partition
      sib.vec <- sib.parts[, j] # membership vector
      n.sib.clones <- max(sib.vec) # number of sibling cells
      sib.clones <- stats::setNames(
        split(clone.names, sib.vec),
        paste0("s", 1:n.sib.clones)
      ) # list of vectors of clonal cell names by sibling cell
      RG <- list(
        clone = clones,
        clone.vec = CP,
        sib = sib.clones,
        sib.vec = sib.vec
      )

      if (igraph) RG <- RG_to_igraph(RG, gs, ts_per_gs)

      RG_i <- RG_i + 1
      RGs[[RG_i]] <- RG
      if (progress.bar) pbar$increment()
    }
  }

  RGs
}

