---
title: "Intra-episode siblings"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intra-episode siblings}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%", # Line width taken up by plot
  fig.dpi = 300, # For quality 
  fig.width = 7, # Increase to zoom out
  fig.height = 4, 
  cache = TRUE
)
```

```{r setup}
library(Pv3Rs)
#options(warn = -1) # Suppress warnings about missing and limited data
sm <- function(...) suppressMessages(...) # Rename to shorten function call
```

Groups of three or more intra-episode siblings are modelled as pairs of
intra-episode siblings under Pv3Rs provided modelled MOIs are based on estimates
from bulk (not single-cell) parasite genetic data because

- MOI estimates based on maximum per-marker allele counts count at most two for
groups of three or more not-half siblings because groups of not-half siblings 
can contribute at most two alleles per marker.

- MOI estimates based on heteroallelic marker counts (e.g., those estimated by
TheRealMcCOIL, coiaf and MOIRE [AT-to-add-REFS]) count at most two for groups of
three or more not-half siblings because data from a group of not-half siblings
can be at-most as diverse across markers as the two parental genotypes from
which they draw (check).

When user specified MOI estimates are more diverse than the data input of
`compute_posterior`, Pv3Rs sums over graphs with cliques of three or more
intra-episode siblings (there is nothing in the data to suggest otherwise); when
the data input of `compute_posterior` are as diverse as the MOIs, graphs with
cliques of three or more intra-sibling parasites have zero likelihood. In either
case, the true number of siblings per group collapses to two per group, capping
elevated maximum probabilities; see following example.

## Example of a group of five intra-episode siblings collapses to two

Before showing how groups of intra-episode siblings collapse to pairs of
intra-episode siblings, we write a function to simulate an enrolment episode
comprising a stranger plus a group of four siblings, two from one oocyst, two
from another, all drawing from the same two unrelated parental genotypes, and a
recurrence with one sibling. Technically, the enrolment episode contains five
genetically distinct genotypes and thus has a MOI of five.

```{r echo = FALSE}
simulate_data <- function(n_alleles){
  
  # Magic numbers / quantities
  set.seed(5) # For reproducibility
  n_markers <- 200 # Number of markers
  n_strangers <- 3 # Number of stranger parasites
  n_oocysts <- 2 # Number of oocysts to draw from
  
  # Derived quantities
  alleles <- letters[1:n_alleles]
  markers <- paste0("m", 1:n_markers) # Marker names
  
  # Uniform allele frequencies 
  fs <- sapply(markers, simplify = FALSE, 
               function(m) setNames(rep(1/n_alleles, n_alleles), alleles))
  
  # Sample strangers
  strangers <- sapply(1:n_strangers, function(i) {
    sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))
  })
  
  # Designate strangers
  parents <- strangers[, 1:2]
  
  # Map the markers to chromosomes. Assume equally sized chromosomes â€” reasonable
  # if and only if we later assume an equal number of crossovers per chromosome
  chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))
  
  # Sample parental allocations dependently per-oocyst 
  cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))
  
  # Construct children from parental allocations 
  all_children <- lapply(1:n_oocysts, function(o) {
    oocyst_chidren <- sapply(1:n_markers, function(i) {
      sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])
    })
    colnames(oocyst_chidren) <- markers
    return(oocyst_chidren)
  })
  
  # Make enrolment infection
  enrol <- apply(rbind(all_children[[1]][1:2,], 
                       all_children[[2]][1:2,], 
                       strangers[,3]), 2, unique, simplify = F)
  
  # Make paired data
  data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))
  
  return(list(data = data, fs = fs))
}
```

However, MOI estimates based on maximum per-marker allele counts are at most
three and one when markers are highly multiallelic:

```{r echo = FALSE}
multiallelic <- simulate_data(10)
determine_MOIs(multiallelic$data)

biallelic <- simulate_data(2)
determine_MOIs(biallelic$data)
```

Suppose we estimate MOIs of 3 and 1 for the biallelic data using a software that
exploits heteroallelic marker counts (rather than the maximum number of
per-marker alleles). Providing data are simulated on a large number of markers 
(200 here), we recover the same probability of recrudescence using both
the

- multiallelic data without user-specified MOIs
- biallelic data with user-specified MOIs based on heteroallelic marker counts 

```{r echo = FALSE}
multi <- sm(compute_posterior(y = multiallelic$data, 
                              fs = multiallelic$fs, return.logp=T))
bi <- sm(compute_posterior(y = biallelic$data, MOIs = c(3,1),
                           fs = biallelic$fs, return.logp=T))

multi$marg
bi$marg
```
However, given multiallelic data the likelihoods of graphs with cliques of three
intra-episode siblings are zero: 

```{r echo = FALSE, fig.cap="Graphs with zero likelihood"} 
MOIs <- c(3,1) # MOIs based on data 
gs <- paste0("g", 1:sum(MOIs)) # Genotype names
ts_per_gs <- rep(1:length(MOIs), MOIs) # Episode indices per genotype
llikes <- sapply(multi$RGs, function(RG) RG$logp) # Extract log likelihoods
par(mar = c(0.5, 0.5, 0.5, 0.5), mfrow = c(1,5)) # Plotting parameters
for(RG in multi$RGs[which(is.infinite(llikes))]) {
plot_RG(RG_to_igraph(RG, gs, ts_per_gs),
        vertex_palette = "Greys",
        edge.curved = 0.08,
        vertex.size = 40,
        edge.width = 3,
        vertex.frame.width = 2,
        vertex.label.cex = 1,
        vertex.label.color = "black")
}
```

Whereas, given biallelic data, all relationships have non-zero likelihoods:

```{r} 
llikes <- sapply(bi$RGs, function(RG) RG$logp) # Extract log likelihoods
any(is.infinite(llikes))
```

The summation over graphs with cliques or three or more siblings is possibly
redundant given these graphs have no practical support. Even when these graphs
have zero likelihood, they contribute to maximum probabilities of recrudescence
/ reinfection through the conditionally uniform prior on graphs. However, the
contribution is generally very small (less than 2.5\%). % See (import data? XXX)
