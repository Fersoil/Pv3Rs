---
title: "Understanding posterior estimates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding posterior estimates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%", # Line width taken up by plot
  fig.dpi = 300, # For quality 
  fig.width = 7, # Increase to zoom out
  fig.height = 4, 
  cache = TRUE
)
```

```{r setup} 
devtools::load_all(".") #library(Pv3Rs)
options(warn = -1) # Suppress warnings about missing and limited data
sm <- function(...) suppressMessages(...) # Rename to shorten function call
```

# Summary

In this vignette we document the output of `compute_posterior` when the
statistical model underpinning it is well specified and misspecified. More
specifically, we document the output of `compute_posterior` when the model is
well specified but

- data are missing,
- data are uninformative, 
- data are limited to only one episode,
- data are incomparable across episodes,
- data are limited to only one marker. 

When the model is well specified and there are data on many markers, we show how
the maximal probability of probable recrudescence / reinfection depends on 1 to 3 as follows and thus has a bearing on 4 as follows.

1) per-episode MOIs
2) episode count (regardless of data)
3) position of the recurrence in the sequence of episodes
4) interpreting uncertainty

Finally, we summarise some [results stored in the development files of the Pv3Rs
source
package](https://github.com/aimeertaylor/Pv3Rs/tree/main/DevFiles/RelationshipStudy)
on the output of `compute_posterior` when the model is misspecified
because of

- meiotic siblings,
- half siblings [sort bounds!],
- parent child-like siblings [sort bounds!],
- genotyping errors or *de novo* mutations [To-do]. 

We have not yet characterised model misspecification due to inbred parasites.
However, we intuit inter-marker dependence will lead to overconfident posterior
probabilities, while population structure could lead to the misclassification of
reinfection as relapse.

```{r echo = FALSE}
# get RG vertex labels, RGs, recurrent state sequences RGs are compatible with
get_graph_dist <- function(x) { 
  gs <- paste0("g", 1:sum(x)) # genotype names (graph vertices)
  ts <- 1:length(x) # episode indices
  ts_per_gs <- rep(ts, x) # episode index of each genotype
  gs_per_ts <- split(gs, ts_per_gs) # genotypes grouped by episode
  RGs <- sm(enumerate_RGs(x)) # all relationship graphs
  CIL_gvn_RGs <- sapply(RGs, compatible_rstrs, gs_per_ts) # compatible states
  return(list(gs = gs, RGs = RGs, CIL_gvn_RGs = CIL_gvn_RGs))
}
```


# Missing data

When data are entirely missing, `compute_posterior` returns the prior. 

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data
sm(compute_posterior(y, fs))$marg # Posterior
```

When data are missing but the user provides MOIs that are incompatible with
recrudescence, `compute_posterior` returns the prior re-weighted to the
exclusion of recrudescence.

```{r}
sm(compute_posterior(y, fs, MOIs = c(1,2)))$marg 
```

# Uniformative data

When data are entirely uninformative because there is no genetic diversity,
`compute_posterior` returns the prior.

```{r}
fs = list(m1 = c("A" = 1)) # Unit allele frequency: no genetic diversity
y = list(list(m1 = "A"), recur = list(m1 = "A")) # Data: not missing
sm(compute_posterior(y, fs))$marg # Posterior
```

# Data on only one episode 

## Monoclonal data

When only one episode has data and its MOI is one, `compute_posterior` returns
the prior.

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y <- list(enroll = list(m1 = NA), recur1 = list(m1 = "A")) # No enrolment data
sm(compute_posterior(y, fs))$marg # Posterior
```

## Multiclonal heteroallelic data 

When only one episode has data and they are heteroallelic, the MOI necessarily
exceeds one because the model assumes no false positivity. The posterior is 
close to (but not equal to) the prior because, for relationship graphs with
intra-episode siblings, heteroallelic data limit summation over
identity-by-descent partitions to partitions with at least two cells for the
episode with data. The lower bound on the cell count increases with the number
of distinct alleles observed.

```{r}
# Allele frequencies 
fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25)) 

# MOI increases with number of observed alleles 
ys <- list(list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)), # Data 
           list(enroll = list(m1 = c('A','B','C')), recur = list(m1 = NA)), 
           list(enroll = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)))
do.call(rbind, lapply(ys, function(y) sm(compute_posterior(y, fs))$marg)) 


# MOI increases with external input
MOIs <- list(c(2,1), c(2,2), c(3,2)) 
y <- list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data 
do.call(rbind, lapply(MOIs, function(x)sm(compute_posterior(y,fs,MOIs=x))$marg)) 
```

## Multiclonal homoallelic data 

If the data are homoallelic, but the MOI is greater than one because of external
input, and the observed allele is rare, the posterior departs from the prior
because rare intra-episode allelic repeats limit the likelihood to summation
over relationship graphs with intra-episode relatedness. We can use different
MOIs to demonstrate this: changing the MOIs changes the summation over
relationship graphs, and thus the posterior output.

```{r}
y <- list(enroll = list(m1 = 'A'), recur = list(m1 = NA)) # Homoallelic data
MOIs <- list(c(2,1), c(2,2), c(3,2)) # Different MOIs with first MOI > 1
fs = list(m1 = c("A" = 0.01, "B" = 0.99)) # Rare observed allele
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Compute posterior 
# ------------------------------------------------------------------------------
posterior <- do.call(rbind, lapply(MOIs, function(x) # Posterior 
  sm(compute_posterior(y, fs, MOIs = x))$marg))

# ------------------------------------------------------------------------------
# Approximate posterior using graphs only
# ------------------------------------------------------------------------------
approximation <- sapply(1:length(MOIs), FUN = function(i) {
  
  gd <- get_graph_dist(MOIs[[i]])
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  
  # Identify RGs with intra-episode relatedness for the initial episode
  if(identical(MOIs[[i]], c(1,1))) { # Monoclonal case is trivial
    RGs_edges_first <- rep(TRUE, length(gd$RGs)) 
  } else { # Make adjacency matrix for the first episode
    MOI1 <- MOIs[[i]][1]; gs1 <- gd$gs[1:MOI1]
    mat <- array(1, dim = c(MOI1, MOI1), dimnames = list(gs1, gs1))
    graph <- igraph::graph_from_adjacency_matrix(mat, diag=F, mode="undirected")
    edges_first <- igraph::as_ids(igraph::E(graph)) # Edges of first episode
    RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG))) 
    RGs_edges_first <- sapply(RGs_edges, function(x) all(edges_first %in% x))
  }
  
  approx_unnormalised <- c(C = sum(RGs_edges_first*RGs_C)/sum(RGs_C),
                           L = sum(RGs_edges_first)/length(gd$RGs),
                           I = sum(RGs_edges_first*RGs_I)/sum(RGs_I))
  approx <- approx_unnormalised/sum(approx_unnormalised)
})

#-------------------------------------------------------------------------------
# Plot probabilities
#-------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posterior, 1, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], pch = 20, cex = 1, col = 1:length(MOIs))
xy <- apply(approximation, 2, project2D) # Project probabilities and plot:
points(x = xy["x", ], y = xy["y", ], col = 1:length(MOIs), cex = 2)
legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", 
                  "Posterior approximation \nbased only on summation \nover graphs"))
legend("right", col = 1:length(MOIs), pch = 20, bty = "n", inset = 0.2,
       legend = sapply(MOIs, paste, collapse = " & "), title = "MOIs")
```

The likelihood is only appreciable for relationship graphs where all parasites
in the first episode are siblings.

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 2
# ------------------------------------------------------------------------------
# Classify graphs
gd <- get_graph_dist(c(3,2))
gs <- gd$gs[1:3] # genotypes in the 1st episode
mat <- array(1, dim = c(3,3), dimnames = list(gs, gs)) # matrix for the 1st
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_1st <- igraph::as_ids(igraph::E(graph)) # Edges of the first episode 
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))
RGs_edges_1st <- sapply(RGs_edges, function(RG_E) all(edges_1st %in% RG_E))
RGs_no_edges_1st <- sapply(RGs_edges, function(RG_E) all(!edges_1st %in% RG_E))

# Get graph log likelihoods
post <- sm(compute_posterior(y, fs, MOIs = c(3,2), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "hotpink", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graphs for MOIs 3 & 2")
points(y = llikes_sorted$x[RGs_edges_1st[llikes_sorted$ix]], col = "black",
       x = which(RGs_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[RGs_no_edges_1st[llikes_sorted$ix]], col="lightgray",
       x = which(RGs_no_edges_1st[llikes_sorted$ix]), pch = 20, cex  = 0.5)
legend("topleft", pch = 20, bty= "n", col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with only siblings within the first episode",
                  "Graphs with some siblings in the first episode",
                  "Graphs with no siblings in the first episode"))
```

Adding recurrences without adding data hardly changes the posterior for a single
recurrence.

```{r}
# Data with different recurrence counts but only the first recurrence has data
ys <- list("1_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA)), 
           "2_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA)), 
           "3_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA), 
                                 recur3 = list(m1 = NA)))

# Posterior for different recurrence counts
t(sapply(ys, function(y) { 
  extra_MOIs <- rep(1, length(y)-2)
  sm(compute_posterior(y, fs, MOIs = c(c(2,2),extra_MOIs)))$marg["recur1",]
}))
```

# Data are incomparable across episodes

When there are data on multiple episodes but no comparable data across episodes,
`compute_posterior` behaves similarly to when data are on only one episode:

- it returns the prior when episodes with data are monoclonal, 
- its output remains close to the prior when calls are heteroallelic,
- its output departs from the prior when the call is multiclonal homoallelic and
the observed allele is rare.

```{r}
# Allele frequencies
fs = list(m1 = c("A" = 0.01, "B" = 0.99), 
          m2 = c("A" = 0.01, "B" = 0.99)) 

# Data with an incomparable homoallelic call
y_hom <- list(enrol = list(m1 = "A", m2 = NA), 
              recur = list(m1 = NA, m2 = "A"))

# Data with an incomparable heteroallelic call
y_het <- list(enrol = list(m1 = c("A", "B"), m2 = NA), 
              recur = list(m1 = NA, m2 = c("A", "B")))


sm(compute_posterior(y_hom, fs))$marg # Prior return 
sm(compute_posterior(y_het, fs))$marg # Prior proximity
sm(compute_posterior(y_hom, fs, MOIs = c(2,2)))$marg # Prior departure
```

# Data on only one marker

When data on a single marker are comparable across episodes, the output of
`compute_posterior` depends on the observation and the frequencies of the
observed alleles. For example,

- A rare match is informative: it quashes the posterior probability of 
reinfection.
- A match with a common allele is not very informative: all states are possible 
*a posteriori*.
- A partial match with a common allele is not very informative: all states are 
possible *a posteriori*.
- A mismatch is informative because the model assumes there are no genotyping 
errors: it quashes the posterior probability of recrudescence.

```{r echo=FALSE}
# Allele frequencies
fs_rare <- list(m1 = c("A" = 0.01, "B" = 0.99))
fs_comn <- list(m1 = c("A" = 0.6, "B" = 0.4)) 

# Data 
match <- list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"))
mismatch <- list(enroll = list(m1 = c("A")), recur1 = list(m1 = "B"))
parmatch <- list(enroll = list(m1 = c("A", "B")), recur1 = list(m1 = "A"))

# Compute posterior probabilities and extract marginal probabilities
posteriors <- rbind(sm(compute_posterior(match, fs_rare))$marg, 
                    sm(compute_posterior(match, fs_comn))$marg, 
                    sm(compute_posterior(mismatch, fs_comn))$marg,
                    sm(compute_posterior(parmatch, fs_comn))$marg)

# Visualise the change in the marginal probability of the first recurrence
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posteriors, 1, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20) # Plot projections
labels <- c("rare match", "common match", "mismatch", "partial common match")
text(x = xy["x", ], y = xy["y", ], pos = 3, cex = 0.75, labels) # Annotate 
```

# Data on many markers

As the data increase with the number of markers genotyped, given equally likely
recurrent states *a priori*, posterior probabilities converge to either

- relapse with posterior probability one, 
- recrudescence with maximal posterior probability less than one, 
- reinfection with maximal posterior probability less than one.

The maximal posterior probabilities of recrudescence and reinfection depend on
the number of parasite genotypes within and across episodes, and the position of
the recurrence the sequence of episodes. 

Using rare matched and mismatched data on 100 markers, we demonstrate the dependence
of maximal probabilities of probable recrudescence and probable reinfection on
parasite genotype counts by increasing per-episode MOIs, thereby increasing
parasite genotype counts within episodes, while adding data inextricably; and by
increasing the number of recurrences, thereby increasing parasite genotype
counts across infections, without adding any data.

```{r}
marker_count <- 100 # Number of markers
ms <- paste0("m", 1:marker_count) # Marker names 
match <- as.list(sapply(ms, function(t) "A")) # List of As for all markers
mismatch <- as.list(sapply(ms, function(t) "B")) # List of Bs for all markers
no_data <- as.list(sapply(ms, function(t) NA)) # List of NAs for all markers
```

## Increasing per-episode MOIs

```{r}
MOIs <- list(c(1,1), c(3,1), c(2,2), c(3,3), c(4,2)) 
fs <- sapply(ms, function(m) c("A" = 0.01, "B" = 0.99), simplify = FALSE)
y_match <- list(enrol = match, recur = match)
y_mismatch <- list(enrol = match, recur = mismatch)
```

```{r echo = FALSE}
results_match <- sapply(MOIs, function(x) 
  sm(compute_posterior(y = y_match, fs, MOIs = x)$marg))
results_mismatch <- sapply(MOIs, function(x) 
  sm(compute_posterior(y = y_mismatch, fs, MOIs = x)$marg))

#------------------------------------------------------------------------------
# Posterior approximation based on graphs only
#------------------------------------------------------------------------------
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  gd <- get_graph_dist(MOIs[[i]])
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  x_match <- c(C = 1/sum(RGs_C), L = 1/length(gd$RGs), I = 0)
  x_mismatch <- c(C = 0, L = 1/length(gd$RGs), I = 1/sum(RGs_I))
  approx <- rbind(x_match/sum(x_match), x_mismatch/sum(x_mismatch))
})

#------------------------------------------------------------------------------
# Plot probabilities
#------------------------------------------------------------------------------
par(mar = c(0,0,0,0)) # Visualise the change 
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = median(xy["x", ]), y = mean(xy["y", ]), 
     labels = "match data", pos = 2, offset = 1) # Annotate

xy <- apply(results_mismatch, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = sum(range(xy["x", ]))/2, y = mean(xy["y", ]), 
     labels = "mismatch data", pos = 3, offset = 1) # Annotate

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

# Add legends
legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0,
       legend = c("Posterior probability", 
                  "Posterior approximation \nbased on summation \nover graphs only"))
legend("right", pch = 20, pt.cex = 2, bty = "n", inset = 0.2,col=1:length(MOIs), 
       legend = gsub("c", "", as.character(MOIs)), title = "MOIs") # legend
```

For rare matched data, the likelihood is only appreciable for relationship
graphs where the parasites in the first episode are all siblings and the
inter-episode edges are clones.

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case with MOIs 3 & 3
# ------------------------------------------------------------------------------
# Classify graphs by state
gd <- get_graph_dist(c(3,3))
RGs_not_I <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) !("I" %in% CIL_gvn_RG))
RGs_C <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) "C" %in% CIL_gvn_RG)
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))

# Make a vector of intra-infection edges by first creating a block diag. matrix
mat <- Matrix::bdiag(lapply(c(3,3),function(x) matrix(1, ncol=x, nrow=x)))
colnames(mat) <- gd$gs; rownames(mat) <- gd$gs
graph <- igraph::graph_from_adjacency_matrix(mat, diag = F, mode = "undirected")
edges_within <- igraph::as_ids(igraph::E(graph))
RGs_edges_within <- sapply(RGs_edges, function(x) all(edges_within %in% x))

# Get graph log likelihoods
y <- y_match
post <- sm(compute_posterior(y, fs, MOIs = c(3,3), return.logp=T))
llikes <- sapply(post$RGs, function(RG) RG$logp) # Extract log likelihoods
llikes_sorted <- sort.int(llikes, index.return = T) # Sort log likelihoods

# Plot log likelihoods by graph classification
plot(llikes_sorted$x, pch = 20, cex = 0.5, col = "lightgray", bty = "n",
     ylab = "Log-likelihood", xlab = "Relationship Graphs for MOIs 3 & 3")
points(y = llikes_sorted$x[(RGs_not_I & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_not_I & RGs_edges_within)[llikes_sorted$ix]),
       col = "hotpink", pch = 20, cex  = 0.5)
points(y = llikes_sorted$x[(RGs_C & RGs_edges_within)[llikes_sorted$ix]], 
       x = which((RGs_C & RGs_edges_within)[llikes_sorted$ix]), 
       col = "black", pch = 20, cex  = 0.5)
legend("bottomright", pch = 20, bty= "n", cex = 0.75,
       col = c("black", "hotpink", "lightgray"), 
       legend = c("Graphs with only siblings in the first episode and inter-episode clones",
                  "Graphs with only siblings in the first episode and inter-episode clones and siblings",
                  "All other graphs"))
```

## Adding recurrences without adding data

```{r}
ys_match <- list("1_recurrence" = list(enroll = match, 
                                       recur1 = match),
                 "3_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data),
                 "5_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data,
                                       recur4 = no_data,
                                       recur5 = no_data))

ys_mismatch <- list("1_recurrence" = list(enroll = match, 
                                          recur1 = mismatch),
                    "3_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data),
                    "5_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data,
                                          recur4 = no_data,
                                          recur5 = no_data))
```

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  sm(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  sm(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])

# ------------------------------------------------------------------------------
# Posterior approximation based on graphs only
# ------------------------------------------------------------------------------
MOIs <- lapply(ys_mismatch, determine_MOIs) # MOIs, same for match and mismatch 
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  
  # Get graphs and the state sequence compatibilities
  gd <- get_graph_dist(MOIs[[i]])
  
  # Recurrent state sequences strings and characters
  sqstr <- unique(unlist(gd$CIL_gvn_RGs)) 
  sqchr <- do.call(cbind, sapply(sqstr, function(x) strsplit(x, split = "")))
  
  # Recurrent state sequences with first episode recrudescence / reinfection 
  sqstr_C_1st <- sqstr[which(sqchr[1,] == "C")] 
  sqstr_I_1st <- sqstr[which(sqchr[1,] == "I")] 
  
  # Graphs compatible with first episode recrudescence / reinfection 
  RGs_C_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_C_1st %in% x))
  RGs_I_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(sqstr_I_1st %in% x))
  
  # Numbers of graphs compatible with each recurrent state sequence
  num_comp <- sapply(sqstr, function(seq) { # All graphs
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x))})
  num_comp_RGs_I_1st <- sapply(sqstr, function(seq) { # With reinfection 1st
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_I_1st)})
  num_comp_RGs_C_1st <- sapply(sqstr, function(seq) { # With recrudesc. 1st 
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_C_1st)})
  
  # Joint probabilities unnormalised and normalised
  joint_match_un <- num_comp_RGs_C_1st / num_comp
  joint_mismatch_un <- num_comp_RGs_I_1st / num_comp
  joint_match <- joint_match_un/sum(joint_match_un)
  joint_mismatch <- joint_mismatch_un/sum(joint_mismatch_un)
  
  # Marginal probabilities
  C_match <- sum(joint_match[sqstr_C_1st])
  I_mismatch <- sum(joint_mismatch[sqstr_I_1st])
  approx <- rbind(c(C = C_match, L = 1 - C_match, I = 0), 
                  c(C = 0, L = 1 - I_mismatch, I = I_mismatch))
})

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:3) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "match data", pos = 3, offset = 1) 

xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:3) # Plot projections
text(mean(xy["x", ]), mean(xy["y", ]), "mismatch data", pos = 3, offset = 1) 

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", 
                  "Posterior approximation \nbased on summation \nover graphs only"))
legend("right", col = c(1:3), pch = "-", pt.cex = 2, bty = "n", inset = 0.2, 
       legend = c(1,3,5), title = "Recurrence\ncount") 
```

## Position in a sequence  

Because the distribution over relationship graphs is not invariant to different
episode orderings (more graphs are compatible with a reinfection at the
beginning than at the end of a sequence of three episodes, for example), the
position of a recurrence in a sequence of episodes has a bearing on posterior
estimates.

This effect is negligable when all episodes have the same data on many markers:

```{r}
y <- list(enroll = match, 
          recur1 = match, 
          recur2 = match, 
          recur3 = match)
sm(compute_posterior(y, fs))$marg
```

Instead, consider sequences of episodes with observations (Os) and episodes with
no data (N). 

```{r}
ys_match <- list("NOO" = list(enroll = no_data, 
                              recur1 = match,
                              recur2 = match),
                 "ONO" = list(enroll = match, 
                              recur1 = no_data,
                              recur2 = match),
                 "OON" = list(enroll = match, 
                              recur1 = match,
                              recur2 = no_data))

ys_mismatch <- list("NOO" = list(enroll = no_data, 
                                 recur1 = match,
                                 recur2 = mismatch),
                    "ONO" = list(enroll = match, 
                                 recur1 = no_data,
                                 recur2 = mismatch), 
                    "OON" = list(enroll = match, 
                                 recur1 = mismatch,
                                 recur2 = no_data))
``` 

The second recurrence in the sequence NOO (upward green 2 triangle) has a higher
probability of recrudescence than the first recurrence in the sequence OON
(upward purple 1 triangle) despite both recurrences having the same rare
observations that match the directly preceding episode.

The second recurrence in the sequence NOO (downward green 2 triangle) has a
lower probability of reinfection than the first recurrence in the sequence OON
(downward purple 1 triangle) despite both recurrences having observations that
mismatch the directly preceding episode.

```{r echo = FALSE}
# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  sm(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  sm(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])
results_match_recur2 <- sapply(results_match, function(x) x["recur2",])
results_mismatch_recur2 <- sapply(results_mismatch, function(x) x["recur2",])

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
cols <- RColorBrewer::brewer.pal(3, "Dark2")
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

n_points <- length(ys_match)
xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_match_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 24, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) 

n_points <- length(ys_mismatch)
xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) 
points(x = xy["x", ], y = xy["y", ], pch = "1", cex = 0.4) 
xy <- apply(results_mismatch_recur2, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 25, bg = cols, col = cols) # Plot 
points(x = xy["x", ], y = xy["y", ], pch = "2", cex = 0.4) # Plot 

legend("topleft", pch = c("1", "2"), bty = "n", inset = 0.1,
       legend = c(": 1st recurrence", ": 2nd recurrence"))
legend("left", pch = c(24, 25), bty = "n", inset = 0.1, pt.bg = "black", 
       legend = c("Match", "Mismatch"), title = "Observation type")
legend("right", col = cols, pch = 20, bty = "n", legend = names(ys_mismatch), 
       title = "Position of no observation (N) \namong observations (Os)") 
```

Unsurprisingly, the posterior of the first recurrence in the sequence NOO is
close to the prior (it has no preceding data), likewise for the second
recurrence in the sequence of OON (it has no data). More surprisingly, for
reasons explain below, the posterior of the first recurrence of the sequence ONO
is not close to the prior, despite having no data.

For match data, strong evidence for a clonal edge between episodes one and three
is incompatible with all three recurrence sequences ending with reinfection
*plus* reinfection followed by recrudescence. Meanwhile, strong evidence for a
clonal edge between episodes two and three is incompatible with all three
recurrence sequences ending with reinfection; and strong evidence for a clonal
edge between episodes one and two is incompatible with all three recurrence
sequences starting with reinfection.

```{r}
epsilon <- .Machine$double.eps # Very small probability
names(which(sm(compute_posterior(y = ys_match[["ONO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_match[["NOO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_match[["OON"]], fs))$joint < epsilon))
```


For mismatch data, strong evidence for a stranger edge between episodes one and
three is only incompatible with a double recrudescence. Meanwhile, strong
evidence for a stranger edge between episodes two and three is incompatible with
all three recurrence sequences ending with recrudescence; and strong evidence
for a clonal edge between episodes one and two is incompatible with all three
recurrence sequences starting with recrudescence.

```{r}
epsilon <- .Machine$double.eps # Very small probability
names(which(sm(compute_posterior(y = ys_mismatch[["ONO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_mismatch[["NOO"]], fs))$joint < epsilon))
names(which(sm(compute_posterior(y = ys_mismatch[["OON"]], fs))$joint < epsilon))
```



# Interpreting uncertainty

The uniform prior over relationship graphs compatible with a given sequence of
recurrent states is not uninformative. When recurrent states are
equally likely *a priori*, maximal probabilities of recrudescence and of
reinfection depend on the number of episodes an individual experiences and on
the per-episode MOIs. Otherwise stated, the posterior recurrent
state space is a function of the prior on the recurrent states, the number of
episodes and their MOIs (Figure XXX).

Consequently, if we use a common threshold to classify probable reinfection /
recrudescence based on genetic data alone (i.e., assuming recurrence states are
equally likely *a priori*), we can discount some individuals based on their
per-episode MOIs alone. For example, with a common reinfection threshold of 0.8,
we can discount all people with a single monoclonal recurrence following a
monoclonal enrollment episode because their posterior reinfection probabilities
will never exceed 0.75, even if their data are highly informative of
reinfection.

```{r}
y <- list(enrol = match, recur = mismatch)
fs <- sapply(ms, FUN = function(m) c("A" = 0.5, "B" = 0.5), simplify = FALSE)

# Using the default uniform prior on recurrent states
sm(compute_posterior(y, fs))$marg
```

A non-uniform prior on recurrent states circumvents this issue:

```{r}
# Using an informative prior on recurrent states
prior <- as.matrix(data.frame("C" = 0.1, "L" = 0.2, "I" = 0.7))
sm(compute_posterior(y, fs, prior))$marg
```

# Meiotic siblings

## Methods 

We simulated data and generated results for an initial infection containing two
or three meiotic siblings and a recurrent

- stranger 
- clone
- regular sibling 
- meiotic sibling

## Results

When the initial infection contains two meiotic siblings `compute_posterior` is
well behaved with maximum likelihood on the true relationship graph (not shown). 
Posterior probabilities converge to

- probable reinfection when the recurrent parasite is a stranger, 
- probable recrudescence when the recurrent parasite is a clone,
- certain relapse when the recurrent parasite is a regular sibling,
- certain relapse when the recurrent parasite is a meiotic sibling. 

```{r echo = FALSE}
MOIs <- "2_1"
cases <- c("Stranger", "Clone", "Regular_sibling", "Meiotic_sibling")




for(case in cases){
  
  if( case == "Stranger") {
    exp_state <- "reinfection"    
  } else if (case == "Clone") {
    exp_state <- "recrudescence"
  } else {
    exp_state <- "relapse"
  }
  
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = sprintf("Posterior %s probability", exp_state))
  
  # Horizontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

When the initial infection contains three meiotic siblings and the recurrent
parasite is either a stranger or a clone, posterior probabilities converge
correctly to probable reinfection and probable recrudescence, respectively. 

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Stranger", "Clone")

for(case in cases){
  
   if( case == "Stranger") {
    exp_state <- "reinfection"    
  } else if (case == "Clone") {
    exp_state <- "recrudescence"
  } else {
    exp_state <- "relapse"
  }

  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", 
       las = 1, xaxt = "n", xlab = "", 
       ylab = sprintf("Posterior %s probability", exp_state))
  
  # Horioutputontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,output$exp_state]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

However, relationship graphs (not shown) are wrong for two reasons:

- all the relationship graphs have two, not three, parasites in the initial 
infection because there are at most two alleles per marker
- the highest likelihood relationship graphs have stranger parasites in the
initial episode because prevalence data from three or four meiotic siblings are
identical to bulk data from parents and the parents are strangers.

We can force the graphs to have the correct parasite count by specifying
external MOIs. Doing so recovers maximum likelihood on true relationship graphs.
However, the correct MOIs are unknowable in practice: a collection of siblings
from the same two parents can only ever have two alleles at a given marker.

When the initial infection contains three meiotic siblings and the recurrent
parasite is a regular or meiotic sibling, posterior probabilities converge to
probable recrudescence with maximum likelihood on graphs with a clonal edge to
the sibling relapse, and either two stranger parasites in the initial episode
when no external MOIs are specified, or three sibling parasites in the initial
episode when the correct MOIs (unknowable in practice) are provided externally.

```{r echo = FALSE}
MOIs <- "3_1"
cases <- c("Regular_sibling", "Meiotic_sibling")

for(case in cases){
  
  rm(list = "output")
  output <- output_Cln.Str.Sib[[case]]
  cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # Colour repeats
  
  # Compute effective cardinality cumulatively
  cum_card_eff <- sapply(output$fs_store, function(fs) {
    cumsum(sapply(fs, function(x) 1/sum(x^2)))})
  
  # Determine which fs in cum_card_eff are equifrequent
  equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)
  
  # Plot trajectories
  plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
       xaxt = "n", xlab = "", ylab = "Posterior recrudescence probability")
  
  # Horioutputontal axis
  axis_at <- c(1, seq(0, max(output$n_markers), 10)[-1])
  axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
  axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
       tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))
  
  title(main = gsub("_", " ", case))
  title(xlab = "Marker count (cumulative effective cardinality)", line = 3.5)
  
  # Add trajectories
  for(i in 1:output$n_repeats){
    lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
          y = sapply(output$ps_store_all_ms_uniform[[MOIs]][[as.character(i)]],
                     function(x) x[,"C"]))
  }
  
  legend("topright", col = cols, lwd = 3, title = "Repeats", box.col = "white",
         legend = 1:output$n_repeats)
}
```

# Half siblings

## Methods 
We simulated data for three half siblings: two in an initial episode, the third
in a recurrence:

- child of parents 1 and 2 in the initial episode
- child of parents 1 and 3 in the initial episode
- child of parents 2 and 3 in the recurrence

We explored two scenarios: one where all parental parasites draw from the same
allele distribution. Another with admixture where parent 1 draws alleles
disproportionally to parents 2 and 3.  The admixture scenario is likely
infrequent. We explore it because it is a worse case scenario: it is contrived
to maximally hamper relapse classification.

## Results

In general, when parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped. 

For this particular case where there are three equifrequent alleles per marker,
we can show theoretically that the system behaves erratically because a small
perturbation to the ratios of observations (all alleles match across
the three half siblings etc.) can lead to a large deviation in the odds of
relapse versus reinfection.


```{r echo = FALSE, fig.height = 4}
rm(list = "output")
output <- output_HalfSib.PCLikeSib[["Half"]]
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") # For repeats

# Compute effective cardinality cumulatively in the order of markers genotyped
cum_card_eff <- sapply(output$fs_store, function(fs) {
  cumsum(sapply(fs[output$m_rorder], function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff)

# Plot the posterior relapse probability trajectories
plot(NULL, bty = "n", las = 1, xaxt = "n", xlim = c(1,max(output$n_markers)), 
     xlab = "Marker count (effective cardinality)", 
     ylim = c(0,1), ylab = "Posterior relapse probability")
legend("right", lwd = 2, col = cols, legend = 1:output$n_repeats, bty = "n", 
       cex = 0.5, title = "Repeat")

# Add expected probability based on normalised odds from on theoretical results
abline(h = 2/11, lty = "dashed") 
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 3)

# Add horizontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  lines(x = 1:max(output$n_markers),
        y = sapply(output$ps_store_all_ms_uniform[[as.character(i)]], 
                   function(x) x[,"L"]),
        col = cols[i], lwd = 2)
}
```
When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
erratically with the number of markers genotyped.

```{r echo = FALSE}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)",
     ylab = "Posterior reinfection probability")

legend("right", col = cols, lwd = 2, inset = 0.1, legend = (1:output$n_repeats)-1, 
       bty = "n", cex = 0.5, title = "Repeats")

# Add horizontal axis
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", round(cum_card_eff[,"0.5"][axis_at])))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],
              function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}
```
In both scenarios, the likelihood of the true graph with siblings within and
across episodes is quashed as soon as distinct alleles from all three parents
are observed at a given marker. In general, 

- when all parasites draw from the same allele distribution, the maximum
likelihood graphs are the two with one inter-episode sibling edge.
- when intra-episode parasites systematically share rare alleles,
the maximum likelihood graph is the one with one intra-episode sibling edge.

# Parent-child like siblings

## Methods 
We simulated data for three parent-child like siblings: 

- child of selfed parent 1 in the initial episode
- child of parents 1 and 2 in the initial episode
- child of selfed parent 2 in the recurrence

Aside: the alternative with both children of selfed parents in the initial
episode is equivalent to the meiotic case above with three mieotic siblings in
the initial episode because prevalence data from three meiotic siblings is
equivalent to prevalence data from two stranger parents and leads to probable
recrudescence rather than certain relapse with the number of markers genotyped.

As for half-siblings, we explored two scenarios: one where all parental
parasites draw from the same allele distribution. Another with admixture where
parent 1 draws alleles disproportionally to parents 2 and 3. The admixture
scenario is likely infrequent. We explore it because it is a worse case
scenario: it is contrived to maximally hamper relapse classification.

## Results

When parental parasites draw from the same allele distribution, the
frequency of certain relapse increases erratically with the number of markers
genotyped.

```{r echo = FALSE}
output <- output_HalfSib.PCLikeSib[["PCLike"]]

# Colours for repeats
cols <- RColorBrewer::brewer.pal(n = output$n_repeats, "Paired") 

# Cumulative eff. cardinality 
cum_card_eff <- sapply(output$fs_store, function(fs) { 
  cumsum(sapply(fs, function(x) 1/sum(x^2)))})

# Determine which fs in cum_card_eff are equifrequent
equifs <- which(as.numeric(colnames(cum_card_eff)) > output$c_cutoff) 

# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1,
     xaxt = "n", xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior relapse probability")
abline(h = 2/11, lty = "dashed") # What is this ??? 
text(x = max(output$n_markers), y = 2/11, labels = "2/11", pos = 3)
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)

# Add horioutputontal axis
axis_at <- c(1, seq(0, max(output$n_markers), 50)[-1])
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.7, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats) {
  lines(x = 1:max(output$n_markers), col = cols[i], lwd = 2, 
        y = sapply(output$ps_store_all_ms_uniform[[as.character(i)]], 
                   function(x) x[,"L"]))
}
```

When intra-episode parasites systematically share rare alleles (admixture AND
imbalanced allele frequencies), the frequency of probable reinfection increases
erratically with the number of markers genotyped.

```{r echo = FALSE}
# Plot the posterior relapse probability trajectories
plot(NULL, xlim = c(1,max(output$n_markers)), ylim = c(0,1), bty = "n", las = 1, 
     xaxt = "n",  xlab = "Marker count (effective cardinality)", 
     ylab = "Posterior reinfection probability")

# Add horioutputontal axis 
axis(side = 1, at = axis_at, cex.axis = 0.7) # Marker count
axis(side = 1, line = 1, at = axis_at, cex.axis = 0.6, # Effective cardinality
     tick = F, labels = sprintf("(%s)", cum_card_eff[,equifs][axis_at]))

# Add trajectories
for(i in 1:output$n_repeats){
  y <- sapply(output$ps_store_all_ms_admix_rare[[as.character(i)]],
              function(x) x[,"I"])
  lines(x = 1:max(output$n_markers), y = y, col = cols[i], lwd = 2)
}

# Add legend
legend("right", col = cols, lwd = 2, inset = 0.1, legend = 1:output$n_repeats,
       bty = "n", title = "Repeats", cex = 0.5)
```

In general, when all parasites draw from the same allele distribution, the
maximum likelihood graph is the true graph with siblings within and across
episodes. Meanwhile, when intra-episode parasites systematically share rare
alleles, the maximum likelihood graph is the one with one intra-episode sibling
edge.






