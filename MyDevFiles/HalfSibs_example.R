################################################################################
# As the number of markers increases, the frequency of relapse classification
# increases, unless intra-episode matches are biased towards rare alleles, where
# rare alleles are generated when the concentration parameter is low (0.1 or 1)
# and where bias is generated by a migrant fathering siblings within but not
# across episodes (rare_enrich_TRUE).
# ==============================================================================
rm(list = ls())
par_default <- par(no.readonly = TRUE)
load("../data/Half_siblings.rda")
attached <- search() # Check no Half_siblings alread attached
if(any(grepl("Half_sibling", attached))) stop("Detach half sibling data")

for(x in c("rare_enrich_FALSE", "rare_enrich_TRUE")) {

  attach(Half_siblings[[x]])
  par(par_default)
  c_params <- names(ys_store)
  n_markers <- as.numeric(names(ys_store[[1]]))
  n_repeats <- length(ys_store[[1]][[1]])

  #===============================================================================
  # Aside: check graphs are all ordered the same [to-do: make into a unit test]
  # Extract graph summary (i.e., discard logp)
  justRGs <- sapply(ps_store, function(X) {
    sapply(X, function(XX) {
      sapply(XX, function(post) {
        sapply(post$RGs, function(RG) c(RG$clone, RG$sib))
      }, simplify = F)
    }, simplify = F)
  }, simplify = F)


  # Check all the graphs are returned in the same order
  justRG <- justRGs[[1]][[1]][[1]]
  RGcheck <- sapply(n_markers, function(m) {
    sapply(c_params, function(c) {
      sapply(2:n_repeats, function(i) {
        identical(justRG, justRGs[[as.character(c)]][[as.character(m)]][[i]])
      })
    })
  })

  if (!all(RGcheck)) stop("graphs not returned in the same order")
  #===============================================================================

  # Extract probability of relapse
  post_L <- sapply(ps_store, function(X) {
    sapply(X, function(XX) {
      sapply(XX, function(XXX) XXX$marg[,"L"])
    }, simplify = F)
  }, simplify = F)

  # Extract exceedance proportion
  prop_L <- sapply(post_L, function(post_L_c) {
    sapply(post_L_c, function(post_L_c_m) mean(post_L_c_m > 0.5))
  })

  # Extract probability of the data given the graph (check)
  llikeRGs <- sapply(ps_store, function(X) {
    sapply(X, function(XX) {
      sapply(XX, function(post) {
        sapply(post$RGs, function(RG) RG$logp)
      }, simplify = F)
    }, simplify = F)
  }, simplify = F)


  # Plots posterior relapse probabilities
  par(mfrow = c(4,1))
  for(c in c_params){
    plot(NULL, xlim = range(n_markers)+c(-10,10), ylim = c(0,1),
         xaxt = "n", bty = "n", panel.first = grid(nx = NA, ny = NULL),
         ylab = "Posterior relapse probability",
         xlab = "Number of markers (with added jitter)",
         main = sprintf("Concentration parameter: %s", c))
    axis(side = 1, at = n_markers)
    for(m in n_markers) {
      points(y = post_L[[as.character(c)]][[as.character(m)]],
             x = jitter(rep(m, n_repeats), amount = 5), pch = 4)
    }
  }

  # Plot exceedance proportion
  par(par_default)
  fields::image.plot(prop_L, axes = FALSE,
                     ylab = "Dirchlet concentration parameter",
                     xlab = "Number of markers",
                     main = "Posterior relapse probability 0.5 exceedence proportion",
                     col = RColorBrewer::brewer.pal(n = 11, "RdBu"),
                     breaks = seq(0,1,length.out = 12))
  axis(at = seq(0,1,length.out = length(n_markers)),
       side = 1, line = -0.5,
       labels = n_markers,
       cex.axis = 1, tick = F)
  axis(at = seq(0,1,length.out = length(c_params)),
       side = 2, line = -0.5, las = 1,
       labels = c_params,
       cex.axis = 1, tick = F)

  # Re-order colours to graph type
  graph_cols <- RColorBrewer::brewer.pal(n = 9, "Paired")[c(7,5,8,9,6,4,3,1,2)]

  # Plot graphs
  par(mfrow = c(3,3))
  for(g in c(8,9,6,7,2,5,4,1,3)) { # Re-order graphs
    ps <- ps_store[[1]][[1]][[1]]
    RG <- ps$RGs[[g]]
    gs <- paste0("g", 1:3)
    ts_per_gs <- c(1, 2, 2)
    par(mar = c(0.5, 0.5, 0.5, 0.5))
    igraphRG <- RG_to_igraph(RG, gs, ts_per_gs) # Convert to igraph object
    igraphRG <- igraph::set_vertex_attr(igraphRG, "name", value = NA) # Remove genotype names
    plot_RG(RG =  igraphRG, vertex_palette = "Greys", labels = NA)
    box(col = graph_cols[g], lwd = 3)
  }

  # For each m, c combination, plot the graph likelihood and data
  for(c in c_params){
    par(mfcol = c(n_repeats,length(n_markers)), mar = c(0,0,0,0)) # Assumes n_repeats = 16
    for(m in n_markers){
      for(i in 1:n_repeats) {
        x <- llikeRGs[[as.character(c)]][[as.character(m)]][[i]]
        x[x == -Inf] <- NA # Mask -Inf
        x <- x - min(x, na.rm = T) # Re-scale before exponentiating (otherwise all 0)
        x <- exp(x)/sum(exp(x), na.rm = T) # Exponentiate and normalise
        pie(x[!is.na(x)], col = graph_cols[!is.na(x)], labels = NA, border = NA)
        symbols(x = 0, y = 0, circles = c(0.25), inches = FALSE, bg = "white", fg = "white", add = TRUE)
        mtext(text = round(post_L[[as.character(c)]][[as.character(m)]][[i]], 2),
              side = 4, line = -4, las = 1, cex = 0.5)
      }
      mtext(text = sprintf("concentration %s, marker count %s", c, m), side = 1, cex = 0.5, line = -1)
    }
  }

  # Plot data
  for(c in c_params) {
    ys <- ys_store[[as.character(c)]][[as.character(n_markers[1])]]
    names(ys) <- 1:n_repeats
    fs = fs_store[[as.character(c)]][[as.character(n_markers[1])]]

    # For small concentration frequencies, some allele frequencies are liable to
    # be near zero. If some allele frequencies are near zero, add an arbitrary
    # small value to all frequencies, to over-ride error.
    fs_no_small <- sapply(fs, function(x) {
      if (any(x < 0.001)) {
        z <- x + 0.001
        names(z) <- names(x)
        return(z)
      } else {
        return(x)
      }}, simplify = F)

    plot_data(ys, fs = fs_no_small, marker_annotate = FALSE)
  }

  detach(Half_siblings[[x]])
  par(par_default)
}

