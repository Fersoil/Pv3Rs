% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_posterior.R
\name{compute_posterior}
\alias{compute_posterior}
\title{Compute posterior probabilities of \emph{P. vivax} recurrent states}
\usage{
compute_posterior(
  y,
  fs,
  prior = NULL,
  MOIs = NULL,
  return.RG = FALSE,
  return.logp = FALSE
)
}
\arguments{
\item{y}{Observed data in the form of a list of lists. The outer list is a
list of episodes in increasing chronological order. The inner list is a list of named
markers per episode. Episode names can be specified, but they are not used.
Markers must be named. Each episode must list the same markers. If not all
markers are typed per episode, data on untyped markers can be encoded as
missing (see below). For each marker, one must specify an allelic vector: a
set of distinct alleles detected at that marker. \code{NA}s encode missing
per-marker data, i.e., when no alleles are observed for a given marker.
\code{NA} entries in allelic vectors that contain both \code{NA} and
non-\code{NA} entries are ignored. Allele names are arbitrary, but must
correspond with frequency names (see examples below). The same names can be
used for alleles belonging to different markers. As such, frequencies must
be specified per named allele per named marker.}

\item{fs}{List of per-marker allele frequency vectors. Names of the list must match
with the marker names in \code{y}. Within lists (i.e., for each marker),
frequencies must be specified per allele name.}

\item{prior}{Matrix of prior probabilities of the recurrence states for each
recurrent episode. Each row corresponds to an episode in increasing
chronological order. The column names must be C, L, and I for
recrudescence, relapse and reinfection respectively. Row names can be
specified but they are not used. If \code{prior} is NULL (default), per-episode
recurrent states are equally likely.}

\item{MOIs}{Multiplicity of infection for each episode. If MOIs are not
provided, the most parsimonious MOIs compatible with the data will be used;
see \code{\link{determine_MOIs}}.}

\item{return.RG}{Boolean for whether to return the relationship graphs,
defaults to \code{FALSE}. If \code{return.logp} is set to \code{TRUE}, then \code{return.RG}
is overridden to be \code{TRUE}, as log-probabilities are returned for each
relationship graph.}

\item{return.logp}{Boolean for whether to return the log-likelihood for each
relationship graph, defaults to \code{FALSE}. When setting \code{return.logp} to
\code{TRUE}, \code{return.RG} should also be set to \code{TRUE}. Setting \code{return.logp} to
\code{FALSE} allows for permutation symmetries to be exploited to save
computational time, see \code{\link{enumerate_alleles}}. Setting this to
\code{TRUE} will result in longer runtimes, especially when multiplicities of
infection are large. Note that this argument does not affect the output of
the posterior probabilities.}
}
\value{
List containing:
\describe{
\item{\code{marg}}{Matrix of marginal posterior probabilities of the possible
recurrence states for each recurrent episode, one row per reinfection.
This is a summary of the results in \code{joint} (see next), in the sense that
each marginal probability is the sum of joint probabilities from \code{joint}
over the corresponding recurrence sequences.}
\item{\code{joint}}{Vector of joint posterior probabilities of each possible string
of recurrence states.}
\item{\code{RGs}}{List of relationship graphs with their log-likelihoods stored.
Only returned if \code{return.RG} is \code{TRUE}. See
\code{\link{enumerate_RGs}}.}
}
}
\description{
Compute posterior probabilities of \emph{P. vivax} recurrent states relapse,
reinfection and recrudescence using genetic data.

Please note, the progress bar does not necessarily increment uniformly (see
details below); it may seem stuck when the code is still running.
}
\details{
\code{compute_posterior()} computes posterior probabilities proportional to the likelihood multiplied by the prior. The likelihood
sums over
\itemize{
\item ways to phase allelic data onto haploid genotypes
\item graphs of relationships between haploid genotypes
\item ways to partition alleles into clusters of identity-by-descent
}

\code{compute_posterior()} expects each per-episode, per-marker allelic
vector to be a set of distinct alleles. Allele repeats at markers with
observed data, and \code{NA} repeats at markers with missing data, are
removed in a data pre-processing step. \code{NA}s in allelic vectors that
also contain non-\code{NA} values are removed in a data pre-processing step.

We enumerate all possible relationship graphs between haploid genotypes,
where pairs of genotypes can either be clones, siblings, or strangers. The
likelihood of a sequence of recurrence states can be determined from the
likelihood of all relationship graphs compatible with said sequence. More
details on the enumeration and likelihood calculation of relationship graphs
can be found in \code{\link{enumerate_RGs}} and \code{\link{RG_inference}}
respectively. For each relationship graph, the model sums over all possible
identity-by-descent partitions. Because some relationship graphs are
compatible with more identity-by-descent partitions than others, the log
p(Y|RG) progress bar does not necessarily increment uniformly.

Notable model assumptions and limitations:
\itemize{
\item{Perfect detection of alleles (no genotyping error)}
\item{No within-host \emph{de novo} mutations}
\item{Parasites are outbred}
\item{All siblings are regular siblings}
\item{Relationship graphs compatible with a given sequence of recurrent
states are equally likely \emph{a priori}}
\item{We do not recommend running `compute_posterior() when the total
genotype count (sum of per-episode multiplicities of infection) exceeds
eight, because there are too many relationship graphs.}
\item{Presently, \code{Pv3Rs} only supports prevalence data (categorical data that
signal the detection of alleles), not quantitative data (data that signal the proportional
abundance of the alleles detected).}
}
}
\examples{
# ===========================================================================
# Example where alleles are named numerically
# ===========================================================================
# Data
y <- list(enroll = list(m1 = c('3','2'), m2 = c('1','2')),
          recur1 = list(m1 = c('1','4'), m2 = c('1')),
          recur2 = list(m1 = c('1'), m2 = NA))

# Allele frequencies
fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),
           m2 = c('1' = 0.27, '2' = 0.73))

# Compute posterior probabilities using default prior
compute_posterior(y, fs)


# ===========================================================================
# Example where alleles are named arbitrarily and probabilities are plotted
# ===========================================================================
# Data
y <- list(episode0 = list(marker1 = c("Tinky Winky", "Dipsy"),
                          marker2 = c("Tinky Winky", "Laa-Laa", "Po")),
          episode1 = list(marker1 = "Tinky Winky",
                          marker2 = "Laa-Laa"))

# Allele frequencies
fs <- list(marker1 = c("Tinky Winky" = 0.4, "Dipsy" = 0.6),
           marker2 = c("Tinky Winky" = 0.1, "Laa-Laa" = 0.1, "Po" = 0.8))

# Compute posterior probabilities using default prior
posterior_probs <- compute_posterior(y, fs)

# Plot posterior probabilities on the simplex
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Simplex
xy <- project2D(posterior_probs$marg[1,]) # Project probabilities
points(x = xy["x"], y = xy["y"], pch = 20) # Plot projected probabilities


#============================================================================
# Demonstrating the return of the prior when all data are missing
#============================================================================
# Data
y_missing <- list(enroll = list(m1 = NA),
                  recur1 = list(m1 = NA),
                  recur2 = list(m1 = NA))

# Return of the prior
suppressMessages(compute_posterior(y_missing, fs = list(m1 = c("A" = 1))))

# Return of the prior re-weighted to the exclusion of recrudescence
suppressMessages(compute_posterior(y_missing, fs = list(m1 = c("A" = 1)),
                 MOIs = c(1,2,3)))

# (Recrudescing parasites are clones of previous blood-stage parasites. The
# Pv3R model assumes no within-host de-novo mutations and perfect allele
# detection. As such, recrudescence is incompatible with an MOI increase on
# the preceding infection.)


# ===========================================================================
# Demonstrating the cosmetic-only nature of episode names
# ===========================================================================
# Data
y <- list(enroll = list(m1 = NA),
          recur2 = list(m1 = NA),
          recur1 = list(m1 = NA))

# Use a non-uniform prior for the purpose of illustration
prior <- matrix(c(0.2,0.2,0.6,0.7,0.1,0.2), byrow = TRUE, nrow = 2,
                dimnames = list(c("recur1_prior", "recur2_prior"),
                                c("C", "L", "I")))

# Print posterior and prior, noting that "recur1_prior" is returned for
# "recur2", and "recur2_prior" is returned for "recur1"
suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg
prior


#============================================================================
# Demonstrating the informative nature of non-recurrent data
#============================================================================
# Data and allele frequencies
y_het <- list(list(m1 = c('1', '2')), list(m1 = NA))
y_hom <- list(list(m1 = '1'), list(m1 = NA))
fs = list(m1 = c('1' = 0.5, '2' = 0.5))

# The prior is not returned despite there being no recurrent data (see
# vignette XXX to understand why)
suppressMessages(compute_posterior(y = y_het, fs))$marg
suppressMessages(compute_posterior(y = y_hom, fs, MOIs = c(2,1)))$marg



#============================================================================
# Demonstrating the effect of increasingly large relationship graphs: the
# marginal probability of the first recurrence changes slightly, albeit at a
# decreasing rate, as the number of additional recurrences (all without data)
# increases. The change is greatest when the observed allele is rare.
#============================================================================
# Data for different recurrence counts where only the 1st recurrence has data
ys <- list(scenario1 = list(enroll = list(m1 = "A"),
                            recur1 = list(m1 = "A")),
           scenario2 = list(enroll = list(m1 = "A"),
                            recur1 = list(m1 = "A"),
                            recur2 = list(m1 = NA)),
           scenario3 = list(enroll = list(m1 = "A"),
                            recur1 = list(m1 = "A"),
                            recur2 = list(m1 = NA),
                            recur3 = list(m1 = NA)),
           scenario4 = list(enroll = list(m1 = "A"),
                            recur1 = list(m1 = "A"),
                            recur2 = list(m1 = NA),
                            recur3 = list(m1 = NA),
                            recur4 = list(m1 = NA)))

# Allele frequencies: smaller f_A leads to larger change
f_A <- 0.1; fs <- list(m1 = c("A" = f_A, "Other" = 1-f_A))

# Compute posterior probabilities and extract marginal probabilities
results <- lapply(ys, function(y) compute_posterior(y, fs)$marg)

# Extract results for the first recurrence
results_recur1 <- sapply(results, function(result) result[1,])
results_recur1 # Results are different for different scenarios

# Visualise the change in the marginal probability of the first recurrence
plot_simplex(c("Recrudescence", "Relapse", "Reinfection")) # Plot simplex
xy <- apply(results_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = "-", col = 1:4) # Plot projections
legend("left", col = 1:4, pch = "-", pt.cex = 2, bty = "n", legend = 1:4,
title = "Recurrence \n count") # legend

}
