---
title: "Understanding model behaviour"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{model-ouput}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  fig.dpi=300, # For quality 
  fig.width=7
)
```

```{r setup} 
library(Pv3Rs)
```

## Introduction

Need to work out how best to tabulate log-likelihoods. 

In this vignette we demonstrate how the statistical model underpinning 
`Pv3Rs::compute_posterior` behaves when it is well specified and misspecified. 

* Posterior output when the model is well specified

  + As a function of marker informativeness
  + As a function of multiplicities of infection (MOIs)
  + When  data

* Posterior output when the model is misspecified because of 
  + Genotyping errors or *de novo* mutations
  + Meiotic siblings
  + Parent child-like siblings
  + Half siblings

We have not yet characterised model misspecification due to inbred parasites. 

Before starting, let's define a helper function that, for a given set of MOIs,
extracts the distribution over relationship graphs, which is defined by the
relationship graphs and the recurrent state sequences they are compatible with.

```{r}
# Define function to get gs, RGs, states given RGs, and thus avoid repetition
get_graph_dist <- function(x) {
  gs <- paste0("g", 1:sum(x)) # genotype names
  ts <- 1:length(x) # episode indices
  ts_per_gs <- rep(ts, x) # episode index of each genotype
  gs_per_ts <- split(gs, ts_per_gs) # genotypes grouped by episode
  RGs <- suppressMessages(enumerate_RGs(x)) # all relationship graphs
  CIL_gvn_RGs <- sapply(RGs, compatible_rstrs, gs_per_ts) # compatible states
  return(list(gs = gs, RGs = RGs, CIL_gvn_RGs = CIL_gvn_RGs))
}
```

## Well-specified model behaviour

### Missing / limited data

When data are entirely missing, `compute_posterior` returns the prior. 

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Data
suppressMessages(compute_posterior(y, fs))$marg # Posterior
```

When data are missing but the user provides MOIs that are incompatible with
recrudescence, `compute_posterior` returns the prior re-weighted to the
exclusion of recrudescence.

```{r}
fs = list(m1 = c("A" = 0.5, "B" = 0.5)) # Allele frequencies
y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Data
suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg # Posterior
```

When genetic data are uninformative, `compute_posterior` returns the prior. 

```{r}
fs = list(m1 = c("A" = 1, "B" = 0)) # Allele frequencies
y = list(list(m1 = "A"), recur = list(m1 = "A")) # Data
suppressMessages(compute_posterior(y, fs))$marg # Posterior
suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg # Posterior
```


#### Data on only one episode (no paired data)

When only one episode has data and its MOI is one, `compute_posterior` returns
the prior (possibly re-weighted to the exclusion of recrudescence, depending on
the MOIs of the other episodes).

```{r}
# Allele frequencies
fs = list(m1 = c("A" = 0.5, "B" = 0.5))

# Data for different numbers of recurrences
y <- list(enroll = list(m1 = NA), 
          recur1 = list(m1 = "A"), 
          recur2 = list(m1 = NA), 
          recur3 = list(m1 = NA))

# Marginal posterior probabilities given MOIs > 1 for episodes without data
suppressMessages(compute_posterior(y, fs, MOIs = c(3,1,1,2)))$marg
```

When only one episode has data and its MOI is greater than one, the output of
`compute_posterior` depends on the hetero/homoallelic nature of the data. 

##### Heteroallelic data on only one episode (MOI necessarily exceeds one)

If the data are heteroallelic, the posterior remains close to the prior, both
when the MOI increases with and without the number of distinct alleles observed.

Explanation: A heteroallelic call is compatible with intra-infection siblings
and strangers. As such, a heteroallelic call does not constrain the summation
over relationship graphs. However, for relationship graphs with intra-episode
siblings, the heteroallelic data limits summation over identity-by-descent
partitions to partitions with at least two cells for the episode with data. The
lower bound on the cell count increases with the number of distinct alleles
observed. 

```{r}
# Allele frequencies
fs = list(m1 = c('A' = 0.2, 'B' = 0.2, 'C' = 0.2, 'D' = 0.2, 'E' = 0.2)) 

# MOI increases with number of observed alleles 
ys <- list(list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)), # Data 
           list(enroll = list(m1 = c('A','B','C')), recur = list(m1 = NA)), 
           list(enroll = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)), 
           list(enroll = list(m1 = c('A','B','C','D','E')), recur = list(m1 = NA)))
do.call(rbind, lapply(ys, function(y) # Posterior 
  suppressMessages(compute_posterior(y, fs)$marg))) 

# MOI increases due to external input
y <- list(enroll = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data 
MOIs <- list(c(3,1), c(2,2), c(3,2)) # MOIs
do.call(rbind, lapply(MOIs, function(x) # Posterior 
  suppressMessages(compute_posterior(y, fs, MOIs = x)$marg))) 
```

##### Homoallelic data on only one episode with MOI greater than one

If the data are homoallelic and the allele is rare, the posterior departs from
the prior because rare intra-episode allelic repeats limit the summation over
relationship graphs to relationship graphs with intra-episode relatedness. We
can use different MOIs to demonstrate this: changing the MOIs changes the
distribution over relationship graphs, and thus the posterior value.

```{r, cache = TRUE}
#-------------------------------------------------------------------------------
# Generate input for homoallelic data on only one episode with MOI > 1
#-------------------------------------------------------------------------------
MOIs <- list(c(2,1), c(3,1), c(2,2), c(3,2), c(3,3)) # Different MOIs 
fs = list(m1 = c("A" = 0.001, "B" = 0.999)) # Allele frequencies
y <- list(enroll = list(m1 = 'A'), recur = list(m1 = NA)) # Data 

#-------------------------------------------------------------------------------
# Compute posterior probabilities for different MOIs 
#-------------------------------------------------------------------------------
posteriors <- do.call(rbind, lapply(MOIs, function(x) 
  suppressMessages(compute_posterior(y, fs, MOIs = x)$marg)))

# ------------------------------------------------------------------------------
# Posterior approximation based on graphs only
# ------------------------------------------------------------------------------
approximation <- sapply(1:length(MOIs), FUN = function(i) {
  
  gd <- get_graph_dist(MOIs[[i]])
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  
  # Identify RGs with intra-episode relatedness for the initial episode
  if(identical(MOIs[[i]], c(1,1))) { # Monoclonal case is trivial
    RGs_edges_first <- rep(TRUE, length(gd$RGs)) 
  } else { # Make adjacency matrix for the first episode
    MOI1 <- MOIs[[i]][1]; gs1 <- gd$gs[1:MOI1]
    mat_first <- array(1, dim = c(MOI1, MOI1), dimnames = list(gs1, gs1))
    graph_first <- igraph::graph_from_adjacency_matrix(mat_first, diag = F,
                                                       mode = "undirected")
    edges_first <- igraph::as_ids(igraph::E(graph_first)) # Edges 
    RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG))) 
    RGs_edges_first <- sapply(RGs_edges, function(RG_E) {
      all(edges_first %in% RG_E)})
  }
  
  approx_unnormalised <- c(C = sum(RGs_edges_first*RGs_C)/sum(RGs_C),
                           L = sum(RGs_edges_first)/length(gd$RGs),
                           I = sum(RGs_edges_first*RGs_I)/sum(RGs_I))
  approx <- approx_unnormalised/sum(approx_unnormalised)
})

#-------------------------------------------------------------------------------
# Plot probabilities
#-------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posteriors, 1, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, cex = 1, col = 1:length(MOIs))

xy <- apply(approximation, 2, project2D)
points(x = xy["x", ], y = xy["y", ], col = 1:length(MOIs), cex = 2)

legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", "Relative weighted graphs"))
legend("right", col = 1:length(MOIs), pch = 20, bty = "n", inset = 0.2,
       legend = sapply(MOIs, paste, collapse = " & "), title = "MOIs")
```

```{r}
# ------------------------------------------------------------------------------
# Maximum likelihood graphs for illustrative case MOIs c(3,3)
# ------------------------------------------------------------------------------
gd <- get_graph_dist(c(3,3))
gs <- paste0("g", 1:3)
mat_first <- array(1, dim = c(3, 3), dimnames = list(gs, gs))
graph_first <- igraph::graph_from_adjacency_matrix(mat_first, diag=F, 
                                                   mode = "undirected")
edges_first <- igraph::as_ids(igraph::E(graph_first))
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))
RGs_edges_first <- sapply(RGs_edges, function(RG_E) all(edges_first %in% RG_E))
post33  <- suppressMessages(compute_posterior(y, fs, MOIs=c(3,3), return.logp=T))
llikelihoods <- sapply(post33$RGs, function(RG) RG$logp)
#print(llikelihoods)
```

Increasing the number of recurrences without adding data has little effect: the
posterior is close to the value for a single recurrence. 

```{r}
# Allele frequencies (no impact)
fs = list(m1 = c("A" = 0.001, "B" = 0.99)) # Allele frequencies

# The number of recurrences increases but only the first has data
ys <- list("1_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA)), 
           "2_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA)), 
           "3_recurrence" = list(enroll = list(m1 = "A"), 
                                 recur1 = list(m1 = NA), 
                                 recur2 = list(m1 = NA), 
                                 recur3 = list(m1 = NA)))

# Compute posterior probabilities and extract marginal probabilities
sapply(ys, function(y) {
  MOIs <- c(2,2,rep(1, length(y)-2))
  suppressMessages(compute_posterior(y, fs, MOIs = MOIs))$marg["recur1",]
})
```

#### Data on more than one episode

When there are data on multiple episodes but no comparable data across episodes,
`compute_posterior` behaves similarly to when data are on only one episode:

- it returns the prior when episodes with data have MOIs of one, 
- its output remains close to the prior when calls are heteroallelic,
- its output departs from the prior when MOIs of episodes with data exceed one, 
  the call is homoallelic and the allele is rare

```{r}
# Allele frequencies
fs = list(m1 = c("A" = 0.001, "B" = 0.999), 
          m2 = c("A" = 0.001, "B" = 0.999), 
          m3 = c("A" = 0.001, "B" = 0.999))

# Data for different numbers of recurrences
y_hom <- list(enroll = list(m1 = "A", m2 = NA, m3 = NA), 
              recur1 = list(m1 = NA, m2 = "A", m3 = NA), 
              recur2 = list(m1 = NA, m2 = NA, m3 = "A"))

y_het <- list(enroll = list(m1 = c("A", "B"), m2 = NA, m3 = NA), 
              recur1 = list(m1 = NA, m2 = c("A", "B"), m3 = NA), 
              recur2 = list(m1 = NA, m2 = NA, m3 = c("A", "B")))

# Marginal posterior probabilities given MOIs > 1 for episodes without data
suppressMessages(compute_posterior(y_hom, fs))$marg # Prior return 
suppressMessages(compute_posterior(y_het, fs))$marg # Prior proximity
suppressMessages(compute_posterior(y_hom, fs, MOIs = c(2,2,2)))$marg # Departure
```

When data on a single marker are comparable across episodes, the output
of `compute_posterior` depends on whether the observation is a match with a
common allele, a match with a rare allele, or a mismatch.

- A match with a common allele is not very informative: all states are possible 
*a posteriori* and the posterior is close to the prior.
- A rare match is informative: it quashes the posterior probability of 
reinfection.
- A mismatch is informative because the model assumes there are no genotyping 
errors: it quashes the posterior probability of recrudescence.

```{r}
# Allele frequencies
fs_comn = list(m1 = c("A" = 0.8, "B" = 0.2)) 
fs_rare <- list(m1 = c("A" = 0.001, "B" = 0.999))

# Data 
match <- list(enroll = list(m1 = "A"), recur1 = list(m1 = "A"))
mismatch <- list(enroll = list(m1 = "A"), recur1 = list(m1 = "B"))

# Compute posterior probabilities and extract marginal probabilities
posteriors <- rbind(suppressMessages(compute_posterior(match, fs_comn))$marg, 
                    suppressMessages(compute_posterior(match, fs_rare))$marg, 
                    suppressMessages(compute_posterior(mismatch, fs_rare))$marg)

# Visualise the change in the marginal probability of the first recurrence
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex
xy <- apply(posteriors, 1, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20) # Plot projections
text(x = xy["x", ], y = xy["y", ], pos = 3, # Annotate
     labels = c("common match", "rare match", "mismatch")) 
```

Given equal probabilities of relapse, recrudescence and reinfection *a priori*, posterior
probabilities converge to either

- relapse with posterior probability one, 
- recrudescence with maximal posterior probability less than one, 
- reinfection with maximal posterior probability less than one, 

as the data increase with the number of markers genotyped.  

The maximal posterior probabilities of recrudescence and reinfection depend on
the distribution over relationship graphs. 

We demonstrate this dependence in isolation by increasing the number of
recurrences (and thus changing the distribution over graphs) without adding any
data. The distribution over relationship graphs also changes with MOIs. However,
when MOIs increase, the amount of data also increases inextricably.

##### Dependence of maximal recrudscence/reinfection probability on graphs 

Increasing the number of recurrences without adding data... 


```{r}
marker_count <- 100
ms <- paste0("m", 1:marker_count)
match <- as.list(sapply(ms, function(t) "A"))
mismatch <- as.list(sapply(ms, function(t) "B"))
no_data <- as.list(sapply(ms, function(t) NA))
fs <- sapply(ms, FUN = function(m) c("A" = 0.01, "B" = 0.99), simplify = FALSE)

# # Alternative data 
# set.seed(1)
# allele_count <- 10 # Data informativeness
# alleles <- LETTERS[1:allele_count]
# fs <- sapply(ms, function(m) {
#   setNames(MCMCpack::rdirichlet(1, rep(1, allele_count)), alleles)
# }, USE.NAMES = TRUE, simplify = FALSE)
# clone <- as.list(sapply(ms, function(t) sample(alleles, 1, prob = fs[[t]])))
# stranger1 <- as.list(sapply(ms, function(t) sample(alleles, 1, prob = fs[[t]])))
# stranger2 <- as.list(sapply(ms, function(t) sample(alleles, 1, prob = fs[[t]])))

ys_match <- list("1_recurrence" = list(enroll = match, 
                                       recur1 = match),
                 "2_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data),
                 "3_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data),
                 "4_recurrence" = list(enroll = match, 
                                       recur1 = match,
                                       recur2 = no_data,
                                       recur3 = no_data,
                                       recur4 = no_data))

ys_mismatch <- list("1_recurrence" = list(enroll = match, 
                                          recur1 = mismatch),
                    "2_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data),
                    "3_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data),
                    "4_recurrence" = list(enroll = match, 
                                          recur1 = mismatch,
                                          recur2 = no_data,
                                          recur3 = no_data,
                                          recur4 = no_data))

# ------------------------------------------------------------------------------
# Posterior based on model
# ------------------------------------------------------------------------------
results_match <- lapply(ys_match, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})
results_mismatch <- lapply(ys_mismatch, function(y) {
  suppressMessages(compute_posterior(y, fs)$marg)})

# Extract results for the first recurrence
results_match_recur1 <- sapply(results_match, function(x) x["recur1",])
results_mismatch_recur1 <- sapply(results_mismatch, function(x) x["recur1",])

# ------------------------------------------------------------------------------
# Posterior based on graphs only
# ------------------------------------------------------------------------------
MOIs <- lapply(ys_mismatch, determine_MOIs) # MOIs, same for match and mismatch 
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  gd <- get_graph_dist(MOIs[[i]])
  
  # Recurrent state sequences strings and characters
  seqs_str <- unique(unlist(gd$CIL_gvn_RGs)) 
  seqs_chr <- do.call(cbind, sapply(seqs_str, function(x) {
    strsplit(x, split = "")}))
  
  # Recurrent state sequences with recrudescence / reinfection first 
  seqs_str_C_1st <- seqs_str[which(seqs_chr[1,] == "C")] 
  seqs_str_I_1st <- seqs_str[which(seqs_chr[1,] == "I")] 
  
  # Graphs compatible with recrudescence / reinfection first 
  RGs_C_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(seqs_str_C_1st %in% x))
  RGs_I_1st <- sapply(gd$CIL_gvn_RGs, function(x) any(seqs_str_I_1st %in% x))
  
  # Numbers of graphs compatible with each recurrent state sequence
  num_comp <- sapply(seqs_str, function(seq) { # All graphs
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x))})
  num_comp_RGs_I_1st <- sapply(seqs_str, function(seq) { # With reinfection 1st
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_I_1st)})
  num_comp_RGs_C_1st <- sapply(seqs_str, function(seq) { # With recrudesc. 1st 
    sum(sapply(gd$CIL_gvn_RGs, function(x) seq %in% x)*RGs_C_1st)})
  
  # Joint probabilities unnormalised and normalised
  joint_match_un <- num_comp_RGs_C_1st / num_comp
  joint_mismatch_un <- num_comp_RGs_I_1st / num_comp
  joint_match <- joint_match_un/sum(joint_match_un)
  joint_mismatch <- joint_mismatch_un/sum(joint_mismatch_un)
  
  # Marginal probabilities
  C_match <- sum(joint_match[seqs_str_C_1st])
  I_mismatch <- sum(joint_mismatch[seqs_str_I_1st])
  approx <- rbind(c(C = C_match, L = 1 - C_match, I = 0), 
                  c(C = 0, L = 1 - I_mismatch, I = I_mismatch))
})

# ------------------------------------------------------------------------------
# Plot probabilities
# ------------------------------------------------------------------------------
par(mar = c(0,0,0,0))
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:4) # Plot projections
text(x = mean(xy["x", ]), # Annotate
     y = mean(xy["y", ]), labels = "match data", pos = 3, offset = 1) 

xy <- apply(results_mismatch_recur1, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:4) # Plot projections
text(x = mean(xy["x", ]), # Annotate
     y = mean(xy["y", ]), labels = "mismatch data", pos = 3, offset = 1) 

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0, 
       legend = c("Posterior probability", "Maximal probability given graphs"))
legend("right", col = 1:4, pch = "-", pt.cex = 2, bty = "n", inset = 0.2, 
       legend = 1:4, title = "Recurrence\ncount") 
```

Increasing MOIs (data increase inextricably)... 

```{r}
MOIs <- list(c(1,1), c(2,1), c(3,1), c(2,2), c(3,2), c(3,3), c(4,2))

results_match <- sapply(MOIs, function(x) 
  suppressMessages(compute_posterior(y = ys_match[["1_recurrence"]], fs, MOIs = x)$marg))
results_mismatch <- sapply(MOIs, function(x) 
  suppressMessages(compute_posterior(y = ys_mismatch[["1_recurrence"]], fs, MOIs = x)$marg))

#------------------------------------------------------------------------------
# Posterior approximation based on graphs only: prior on graphs re-weighted
#------------------------------------------------------------------------------
approximation <- lapply(1:length(MOIs), FUN = function(i) {
  gd <- get_graph_dist(MOIs[[i]])
  RGs_I <- sapply(gd$CIL_gvn_RGs, function(RG) "I" %in% RG)
  RGs_C <- sapply(gd$CIL_gvn_RGs, function(RG) "C" %in% RG)
  x_match <- c(C = 1/sum(RGs_C), L = 1/length(gd$RGs), I = 0)
  x_mismatch <- c(C = 0, L = 1/length(gd$RGs), I = 1/sum(RGs_I))
  approx <- rbind(x_match/sum(x_match), 
                  x_mismatch/sum(x_mismatch))
})

#------------------------------------------------------------------------------
# Posterior approximation based on graphs only: prior on graphs re-weighted
#------------------------------------------------------------------------------
par(mar = c(0,0,0,0)) # Visualise the change 
plot_simplex(c("Recrudescence", "Relapse", "Reinfection"), 0.5) # Plot simplex

xy <- apply(results_match, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = median(xy["x", ]), y = mean(xy["y", ]), 
     labels = "match data", pos = 2, offset = 1) # Annotate

xy <- apply(results_mismatch, 2, project2D) # Project probabilities
points(x = xy["x", ], y = xy["y", ], pch = 20, col = 1:length(MOIs)) # Plot 
text(x = sum(range(xy["x", ]))/2, y = mean(xy["y", ]), 
     labels = "mismatch data", pos = 3, offset = 1) # Annotate

# Add approximations based on graphs only
xys <- lapply(approximation, function(x) apply(x, 1, project2D)) 
for(i in 1:length(xys)) {
  xy <- xys[[i]]
  points(x = xy["x", ], y = xy["y", ], col = i, cex = 2) 
}

# Add legends
legend("left", pch = c(20, 1), pt.cex = c(1, 2), bty = "n", inset = 0,
       legend = c("Posterior probability", "Maximal probability"))
legend("right", pch = 20, pt.cex = 2, bty = "n", inset = 0.2,col=1:length(MOIs), 
       legend = gsub("c", "", as.character(MOIs)), title = "MOIs") # legend


# ------------------------------------------------------------------------------
# Maximum likelihood graphs for matching c(3,3) case are limited to those with
# intra-infection relatedness compatible with recrudescence or relapse.
# ------------------------------------------------------------------------------
gd <- get_graph_dist(c(3,3))
RGs_C_or_L <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) !("I" %in% CIL_gvn_RG))
RGs_C <- sapply(gd$CIL_gvn_RGs, function(CIL_gvn_RG) "C" %in% CIL_gvn_RG)

# Make a vector of intra-infection edges by first creating a block diag. matrix
mat_within <- Matrix::bdiag(lapply(c(3,3),function(x) matrix(1, ncol=x, nrow=x)))
colnames(mat_within) <- gd$gs; rownames(mat_within) <- gd$gs
graph_within <- igraph::graph_from_adjacency_matrix(mat_within, diag = F, 
                                                    mode = "undirected")
edges_within <- igraph::as_ids(igraph::E(graph_within))
RGs_edges <- lapply(gd$RGs, function(RG) igraph::as_ids(igraph::E(RG)))
RGs_edges_within <- sapply(RGs_edges, function(x) all(edges_within %in% x))

post33  <- compute_posterior(y = ys_match[["1_recurrence"]], fs, 
                             MOIs = c(3,3), return.logp = TRUE)
logps <- sapply(post33$RGs, function(RG) RG$logp) # extract logp
print(logps)
#table(logps[RGs_C_or_L & RGs_edges_within])
#table(logps[RGs_C & RGs_edges_within])
```


## Interpreting uncertainty

The uniform prior over relationship graphs compatible with a given sequence of
recurrent states is **NOT** uninformative. Consequently, the maximal
probability of recrudescence / reinfection depends on the determinants of
relationship graphs, i.e., the maximal probability of recrudescence /
reinfection depends on the number of recurrences and their MOIs... 



The marginal probabilities of relapse / reinfection of different recurrences
with the same data differ slightly because XXX [discuss with YS]



```{r}
suppressMessages(compute_posterior(y = list(enroll = list(m1 = "A"), 
                                            recur1 = list(m1 = "A"), 
                                            recur2 = list(m1 = "A"), 
                                            recur3 = list(m1 = "A")), 
                                   fs = list(m1 = c("A" = 0.05,"B" = 0.95))))$marg
```





## Siblings and relapse
When the model is well specified and recurrent parasites are regular siblings,
the posterior probability of relapse tends to one regardless of the MOIs.

## matchs and recrudescence 
When the model is well specified and recurrent parasites are matchs, the
posterior probability of recrudescence tends towards a high but non-certain
probability that depends on the MOIs. 

## Strangers and reinfection 
When the model is well specified and recurrent parasites are strangers, the
posterior probability of reinfection tends towards a high but non-certain
probability that depends on the MOIs. 

## Effect of the prior assumption on relationship graphs 

### Non-recurrent data are informative 

### Effect when the graph grows without data

The graph grows without data as the number of recurrences increases but all data are missing 

### Effect when the graph grows with data

The graph grows without data as the MOI increases



# Misspecified model 







